This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: argus_env/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
argus_track/
  core/
    __init__.py
    detection.py
    gps.py
    track.py
  detectors/
    __init__.py
    base.py
    yolov11.py
  trackers/
    __init__.py
    unique_tracker.py
  utils/
    __init__.py
    gps_extraction.py
    gps_motion_prediction.py
    gps_sync_tracker.py
    gps_utils.py
    io.py
    iou.py
    output_manager.py
    overlap_fixer.py
    smart_track_manager.py
    static_car_detector.py
    visualization.py
  __init__.py
  __version__.py
  config.py
  main.py
  requirements.txt
.gitignore
.repomixignore
LICENSE
README.md
repomix.config.json
setup.py

================================================================
Files
================================================================

================
File: argus_track/core/__init__.py
================
"""Core data structures for ByteTrack Light Post Tracking System"""

from .detection import Detection
from .gps import GPSData
from .track import Track

__all__ = ["Detection", "Track", "GPSData"]

================
File: argus_track/core/detection.py
================
"""Detection data structure"""

from dataclasses import dataclass

import numpy as np


@dataclass
class Detection:
    """Single object detection"""

    bbox: np.ndarray  # [x1, y1, x2, y2] format
    score: float  # Confidence score [0, 1]
    class_id: int  # Object class ID
    frame_id: int  # Frame number

    @property
    def tlbr(self) -> np.ndarray:
        """Get bounding box in top-left, bottom-right format"""
        return self.bbox

    @property
    def xywh(self) -> np.ndarray:
        """Get bounding box in center-x, center-y, width, height format"""
        x1, y1, x2, y2 = self.bbox
        return np.array(
            [
                (x1 + x2) / 2,  # center x
                (y1 + y2) / 2,  # center y
                x2 - x1,  # width
                y2 - y1,  # height
            ]
        )

    @property
    def area(self) -> float:
        """Calculate bounding box area"""
        x1, y1, x2, y2 = self.bbox
        return (x2 - x1) * (y2 - y1)

    @property
    def center(self) -> np.ndarray:
        """Get center point of bounding box"""
        x1, y1, x2, y2 = self.bbox
        return np.array([(x1 + x2) / 2, (y1 + y2) / 2])

    def to_dict(self) -> dict:
        """Convert to dictionary representation"""
        return {
            "bbox": self.bbox.tolist(),
            "score": self.score,
            "class_id": self.class_id,
            "frame_id": self.frame_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Detection":
        """Create from dictionary representation"""
        return cls(
            bbox=np.array(data["bbox"]),
            score=data["score"],
            class_id=data["class_id"],
            frame_id=data["frame_id"],
        )

================
File: argus_track/core/gps.py
================
"""GPS data structure"""

from dataclasses import dataclass
from typing import Any, Dict


@dataclass
class GPSData:
    """GPS data for a single frame"""

    timestamp: float
    latitude: float
    longitude: float
    altitude: float
    heading: float
    accuracy: float = 1.0  # GPS accuracy in meters

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation"""
        return {
            "timestamp": self.timestamp,
            "latitude": self.latitude,
            "longitude": self.longitude,
            "altitude": self.altitude,
            "heading": self.heading,
            "accuracy": self.accuracy,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GPSData":
        """Create from dictionary representation"""
        return cls(**data)

    @classmethod
    def from_csv_line(cls, line: str) -> "GPSData":
        """Create from CSV line"""
        parts = line.strip().split(",")
        if len(parts) < 5:
            raise ValueError(f"Invalid GPS data line: {line}")

        return cls(
            timestamp=float(parts[0]),
            latitude=float(parts[1]),
            longitude=float(parts[2]),
            altitude=float(parts[3]),
            heading=float(parts[4]),
            accuracy=float(parts[5]) if len(parts) > 5 else 1.0,
        )

================
File: argus_track/detectors/base.py
================
"""Base detector interface"""

from abc import ABC, abstractmethod
from typing import Any, Dict, List

import numpy as np


class ObjectDetector(ABC):
    """Abstract base class for object detection modules"""

    @abstractmethod
    def detect(self, frame: np.ndarray) -> List[Dict[str, Any]]:
        """
        Detect objects in a frame

        Args:
            frame: Input image as numpy array

        Returns:
            List of detections with keys: bbox, score, class_name, class_id
        """

    @abstractmethod
    def get_class_names(self) -> List[str]:
        """Get list of detectable class names"""

    def set_target_classes(self, target_classes: List[str]) -> None:
        """Set specific classes to detect"""
        self.target_classes = target_classes

================
File: argus_track/utils/gps_motion_prediction.py
================
# argus_track/utils/gps_motion_predictor.py

"""
GPS Motion Prediction for Track Fragmentation Prevention
=======================================================

Calculates vehicle movement from GPS data and predicts where static objects
should appear in the next frame to prevent track fragmentation.

Key Components:
1. GPS Motion Calculator - Converts GPS lat/lon changes to vehicle movement
2. Screen Displacement Predictor - Converts vehicle movement to pixel displacement
3. Position Predictor - Predicts where objects should appear on screen

Camera Model: GoPro Hero 11 Wide Mode
- Horizontal FOV: 122Â°
- Resolution: 1920x1080
"""

import logging
import math
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import numpy as np

from ..core import GPSData


@dataclass
class MotionPredictionConfig:
    """Configuration for GPS motion prediction"""

    # === OBJECT DISTANCE ESTIMATION ===
    default_object_distance_m: float = 30.0  # Assume 30m distance for all objects

    # === GPS PROCESSING ===
    gps_smoothing_window: int = 3  # Moving average window for GPS smoothing
    min_gps_accuracy_m: float = 3.0  # Use prediction when GPS accuracy < 3m
    max_gps_accuracy_m: float = 5.0  # Fallback to existing logic when > 5m
    min_movement_threshold_m: float = 0.001  # Ignore GPS movements smaller than 10cm

    # === CAMERA PARAMETERS (GoPro Hero 11 Wide) ===
    horizontal_fov_degrees: float = 122.0  # Horizontal field of view
    vertical_fov_degrees: float = 69.0  # Vertical field of view
    image_width: int = 1920  # Screen resolution width
    image_height: int = 1080  # Screen resolution height

    # === PREDICTION PARAMETERS ===
    prediction_tolerance_px: float = 15.0  # Tight matching tolerance for predictions
    max_prediction_distance_px: float = 100.0  # Max pixel movement to consider valid
    rotation_enabled: bool = False  # Enable rotation prediction (start False)

    # === DEBUG SETTINGS ===
    enable_debug_logging: bool = True  # Log motion calculations
    enable_prediction_visualization: bool = True  # Show predictions in debug overlay


@dataclass
class VehicleMovement:
    """Represents calculated vehicle movement between two GPS points"""

    # Movement in meters (world coordinates)
    translation_x_m: float  # East-West movement (+ = East)
    translation_y_m: float  # North-South movement (+ = North)
    distance_moved_m: float  # Total distance moved

    # Rotation
    heading_change_deg: float  # Change in heading (+ = clockwise)

    # Metadata
    time_delta_s: float  # Time between GPS points
    speed_ms: float  # Calculated speed
    gps_accuracy_m: float  # Combined GPS accuracy
    is_valid: bool = True  # Whether movement is trustworthy


@dataclass
class ScreenDisplacement:
    """Predicted pixel displacement on screen"""

    displacement_x_px: float  # Horizontal pixel movement (+ = right)
    displacement_y_px: float  # Vertical pixel movement (+ = down)
    confidence: float  # Prediction confidence [0-1]
    method_used: str  # Which calculation method was used


class GPSMotionCalculator:
    """
    Calculates vehicle movement from GPS data using geodetic calculations
    """

    def __init__(self, config: MotionPredictionConfig):
        """Initialize GPS motion calculator"""
        self.config = config
        self.logger = logging.getLogger(f"{__name__}.GPSMotionCalculator")

        # GPS smoothing buffer
        self.gps_history: List[GPSData] = []

        # Earth radius for geodetic calculations (WGS84)
        self.EARTH_RADIUS_M = 6378137.0

        self.logger.info("GPS Motion Calculator initialized")
        if config.enable_debug_logging:
            self.logger.info(
                f"  Object distance assumption: {config.default_object_distance_m}m"
            )
            self.logger.info(
                f"  GPS accuracy thresholds: {config.min_gps_accuracy_m}m - {config.max_gps_accuracy_m}m"
            )

    def calculate_vehicle_movement(
        self, gps_prev: GPSData, gps_current: GPSData
    ) -> VehicleMovement:
        """
        Calculate vehicle movement between two GPS points

        Args:
            gps_prev: Previous GPS data point
            gps_current: Current GPS data point

        Returns:
            VehicleMovement object with calculated movement
        """
        # Add current GPS to smoothing buffer
        self._update_gps_history(gps_current)

        # Use smoothed GPS if available
        smoothed_prev = self._get_smoothed_gps(gps_prev)
        smoothed_current = self._get_smoothed_gps(gps_current)

        # Calculate time delta
        time_delta = smoothed_current.timestamp - smoothed_prev.timestamp

        if time_delta <= 0:
            # Estimate time delta based on frame interval (6 frames at 60fps = 0.1s)
            estimated_time_delta = 6.0 / 60.0  # 0.1 seconds
            self.logger.debug(
                f"Zero time delta detected, using estimated: {estimated_time_delta}s"
            )
            time_delta = estimated_time_delta

        # Continue with existing calculation logic...
        translation_x, translation_y = self._calculate_translation_meters(
            smoothed_prev, smoothed_current
        )

        # Calculate total distance and speed
        distance_moved = math.sqrt(translation_x**2 + translation_y**2)
        speed_ms = distance_moved / time_delta

        # Calculate heading change
        heading_change = self._calculate_heading_change(smoothed_prev, smoothed_current)

        # Determine combined GPS accuracy
        combined_accuracy = max(smoothed_prev.accuracy, smoothed_current.accuracy)

        # Validate movement
        is_valid = self._validate_movement(distance_moved, speed_ms, combined_accuracy)

        movement = VehicleMovement(
            translation_x_m=translation_x,
            translation_y_m=translation_y,
            distance_moved_m=distance_moved,
            heading_change_deg=heading_change,
            time_delta_s=time_delta,
            speed_ms=speed_ms,
            gps_accuracy_m=combined_accuracy,
            is_valid=is_valid,
        )

        if self.config.enable_debug_logging and is_valid:
            self.logger.debug(
                f"Vehicle movement: {distance_moved:.2f}m, "
                f"Speed: {speed_ms*3.6:.1f} km/h, "
                f"Heading change: {heading_change:.1f}Â°"
            )

        return movement

    def _calculate_translation_meters(
        self, gps_prev: GPSData, gps_current: GPSData
    ) -> Tuple[float, float]:
        """
        Calculate translation in meters using Haversine-based local coordinates

        Returns:
            (translation_x_m, translation_y_m) where:
            - x is East-West (+ = East)
            - y is North-South (+ = North)
        """
        # Convert latitude/longitude differences to meters
        lat1_rad = math.radians(gps_prev.latitude)
        lat2_rad = math.radians(gps_current.latitude)

        # Calculate differences
        dlat_rad = lat2_rad - lat1_rad
        dlon_rad = math.radians(gps_current.longitude - gps_prev.longitude)

        # Convert to meters using local approximation
        # (accurate for small distances < 1km)
        translation_y = dlat_rad * self.EARTH_RADIUS_M  # North-South
        translation_x = dlon_rad * self.EARTH_RADIUS_M * math.cos(lat1_rad)  # East-West

        return translation_x, translation_y

    def _calculate_heading_change(
        self, gps_prev: GPSData, gps_current: GPSData
    ) -> float:
        """Calculate change in vehicle heading"""
        heading_prev = gps_prev.heading
        heading_current = gps_current.heading

        # Handle heading wraparound (0Â° = 360Â°)
        heading_change = heading_current - heading_prev

        # Normalize to [-180, 180] range
        while heading_change > 180:
            heading_change -= 360
        while heading_change < -180:
            heading_change += 360

        return heading_change

    def _update_gps_history(self, gps_data: GPSData):
        """Update GPS history for smoothing"""
        self.gps_history.append(gps_data)

        # Keep only recent history
        max_history = self.config.gps_smoothing_window * 2
        if len(self.gps_history) > max_history:
            self.gps_history = self.gps_history[-max_history:]

    def _get_smoothed_gps(self, gps_data: GPSData) -> GPSData:
        """Get smoothed GPS data using moving average"""
        if len(self.gps_history) < self.config.gps_smoothing_window:
            return gps_data

        # Find recent GPS points around this timestamp
        target_time = gps_data.timestamp
        recent_points = []

        for hist_gps in self.gps_history[-self.config.gps_smoothing_window :]:
            time_diff = abs(hist_gps.timestamp - target_time)
            if time_diff < 1.0:  # Within 1 second
                recent_points.append(hist_gps)

        if len(recent_points) < 2:
            return gps_data

        # Calculate weighted average (more recent = higher weight)
        total_weight = 0
        weighted_lat = 0
        weighted_lon = 0
        weighted_heading = 0

        for i, point in enumerate(recent_points):
            weight = i + 1  # Linear weighting
            total_weight += weight
            weighted_lat += point.latitude * weight
            weighted_lon += point.longitude * weight
            weighted_heading += point.heading * weight

        # Create smoothed GPS data
        smoothed_gps = GPSData(
            timestamp=gps_data.timestamp,
            latitude=weighted_lat / total_weight,
            longitude=weighted_lon / total_weight,
            altitude=gps_data.altitude,
            heading=weighted_heading / total_weight,
            accuracy=gps_data.accuracy,
        )

        return smoothed_gps

    def _validate_movement(
        self, distance_moved: float, speed_ms: float, gps_accuracy: float
    ) -> bool:
        """Validate if calculated movement is trustworthy"""

        # Check GPS accuracy
        if gps_accuracy > self.config.max_gps_accuracy_m:
            if self.config.enable_debug_logging:
                self.logger.debug(
                    f"Movement invalid: GPS accuracy too low ({gps_accuracy:.1f}m)"
                )
            return False

        # Check minimum movement threshold
        if distance_moved < self.config.min_movement_threshold_m:
            if self.config.enable_debug_logging:
                self.logger.debug(f"Movement below threshold: {distance_moved:.3f}m")
            return False

        # Check reasonable speed (under 200 km/h = 55 m/s)
        if speed_ms > 55.0:
            if self.config.enable_debug_logging:
                self.logger.debug(
                    f"Movement invalid: Speed too high ({speed_ms*3.6:.1f} km/h)"
                )
            return False

        return True

    def _create_invalid_movement(self, reason: str) -> VehicleMovement:
        """Create invalid movement object with reason"""
        if self.config.enable_debug_logging:
            self.logger.debug(f"Invalid movement: {reason}")

        return VehicleMovement(
            translation_x_m=0.0,
            translation_y_m=0.0,
            distance_moved_m=0.0,
            heading_change_deg=0.0,
            time_delta_s=0.0,
            speed_ms=0.0,
            gps_accuracy_m=999.0,
            is_valid=False,
        )


class ScreenDisplacementPredictor:
    """
    Predicts pixel displacement on screen based on vehicle movement
    """

    def __init__(self, config: MotionPredictionConfig):
        """Initialize screen displacement predictor"""
        self.config = config
        self.logger = logging.getLogger(f"{__name__}.ScreenDisplacementPredictor")

        # Calculate derived camera parameters
        self.horizontal_fov_rad = math.radians(config.horizontal_fov_degrees)
        self.vertical_fov_rad = math.radians(config.vertical_fov_degrees)

        # Pixels per radian
        self.pixels_per_rad_horizontal = config.image_width / self.horizontal_fov_rad
        self.pixels_per_rad_vertical = config.image_height / self.vertical_fov_rad

        self.logger.info("Screen Displacement Predictor initialized")
        if config.enable_debug_logging:
            self.logger.info(
                f"  Camera FOV: {config.horizontal_fov_degrees}Â° x {config.vertical_fov_degrees}Â°"
            )
            self.logger.info(
                f"  Pixels per radian: H={self.pixels_per_rad_horizontal:.1f}, V={self.pixels_per_rad_vertical:.1f}"
            )

    def predict_screen_displacement(
        self,
        vehicle_movement: VehicleMovement,
        object_distance_m: Optional[float] = None,
    ) -> ScreenDisplacement:
        """
        Predict pixel displacement based on vehicle movement

        Args:
            vehicle_movement: Calculated vehicle movement
            object_distance_m: Distance to object (uses default if None)

        Returns:
            ScreenDisplacement with predicted pixel movement
        """
        if not vehicle_movement.is_valid:
            return ScreenDisplacement(
                displacement_x_px=0.0,
                displacement_y_px=0.0,
                confidence=0.0,
                method_used="invalid_movement",
            )

        # Use default object distance if not specified
        if object_distance_m is None:
            object_distance_m = self.config.default_object_distance_m

        # Calculate angular displacement due to translation
        angular_displacement_x, angular_displacement_y = (
            self._calculate_angular_displacement(vehicle_movement, object_distance_m)
        )

        # Convert angular displacement to pixel displacement
        displacement_x_px = angular_displacement_x * self.pixels_per_rad_horizontal
        displacement_y_px = angular_displacement_y * self.pixels_per_rad_vertical

        # Calculate confidence based on GPS accuracy and movement size
        confidence = self._calculate_prediction_confidence(
            vehicle_movement, displacement_x_px, displacement_y_px
        )

        # Validate prediction
        if self._is_prediction_reasonable(displacement_x_px, displacement_y_px):
            method_used = "translation_only"
        else:
            displacement_x_px = 0.0
            displacement_y_px = 0.0
            confidence = 0.0
            method_used = "prediction_too_large"

        if self.config.enable_debug_logging and confidence > 0.5:
            self.logger.debug(
                f"Screen prediction: ({displacement_x_px:.1f}, {displacement_y_px:.1f})px, "
                f"confidence: {confidence:.2f}"
            )

        return ScreenDisplacement(
            displacement_x_px=displacement_x_px,
            displacement_y_px=displacement_y_px,
            confidence=confidence,
            method_used=method_used,
        )

    def _calculate_angular_displacement(
        self, vehicle_movement: VehicleMovement, object_distance_m: float
    ) -> Tuple[float, float]:
        """
        Calculate angular displacement of static objects due to vehicle movement

        Key insight: When vehicle moves, static objects appear to move in opposite direction
        """
        # Vehicle movement in world coordinates
        vehicle_x = vehicle_movement.translation_x_m  # East-West
        vehicle_y = vehicle_movement.translation_y_m  # North-South

        # For static objects, apparent movement is opposite to vehicle movement
        apparent_x = -vehicle_x  # Vehicle moves East â†’ objects appear to move West
        apparent_y = -vehicle_y  # Vehicle moves North â†’ objects appear to move South

        # Convert to angular displacement (small angle approximation)
        # Angular displacement = linear displacement / distance
        angular_x_rad = apparent_x / object_distance_m
        angular_y_rad = apparent_y / object_distance_m

        return angular_x_rad, angular_y_rad

    def _calculate_prediction_confidence(
        self,
        vehicle_movement: VehicleMovement,
        displacement_x_px: float,
        displacement_y_px: float,
    ) -> float:
        """Calculate confidence in the prediction"""

        # Base confidence from GPS accuracy
        accuracy_confidence = 1.0 - min(
            1.0, vehicle_movement.gps_accuracy_m / self.config.max_gps_accuracy_m
        )

        # Movement confidence (very small movements are less reliable)
        movement_confidence = min(
            1.0, vehicle_movement.distance_moved_m / 1.0
        )  # Confident above 1m movement

        # Pixel displacement confidence (very large displacements are suspicious)
        max_reasonable_px = self.config.max_prediction_distance_px
        pixel_displacement = math.sqrt(displacement_x_px**2 + displacement_y_px**2)
        displacement_confidence = max(0.0, 1.0 - pixel_displacement / max_reasonable_px)

        # Combined confidence
        combined_confidence = (
            accuracy_confidence * movement_confidence * displacement_confidence
        )

        return max(0.0, min(1.0, combined_confidence))

    def _is_prediction_reasonable(
        self, displacement_x_px: float, displacement_y_px: float
    ) -> bool:
        """Check if predicted displacement is reasonable"""

        # Check individual axis limits
        if abs(displacement_x_px) > self.config.max_prediction_distance_px:
            return False
        if abs(displacement_y_px) > self.config.max_prediction_distance_px:
            return False

        # Check total displacement
        total_displacement = math.sqrt(displacement_x_px**2 + displacement_y_px**2)
        if total_displacement > self.config.max_prediction_distance_px:
            return False

        return True


class MotionPredictor:
    """
    Main class that combines GPS motion calculation and screen displacement prediction
    """

    def __init__(self, config: MotionPredictionConfig):
        """Initialize motion predictor"""
        self.config = config
        self.logger = logging.getLogger(f"{__name__}.MotionPredictor")

        # Initialize components
        self.gps_calculator = GPSMotionCalculator(config)
        self.screen_predictor = ScreenDisplacementPredictor(config)

        # Statistics
        self.prediction_count = 0
        self.successful_predictions = 0
        self.total_prediction_error = 0.0

        self.logger.info("Motion Predictor initialized")

    def predict_object_positions(
        self,
        gps_prev: GPSData,
        gps_current: GPSData,
        current_track_positions: Dict[int, np.ndarray],
    ) -> Dict[int, Dict]:
        """
        Predict where existing tracked objects should appear in the current frame

        Args:
            gps_prev: Previous GPS data
            gps_current: Current GPS data
            current_track_positions: Dict of {track_id: last_known_position}

        Returns:
            Dict of {track_id: prediction_info} with predicted positions
        """
        predictions = {}

        # Calculate vehicle movement
        vehicle_movement = self.gps_calculator.calculate_vehicle_movement(
            gps_prev, gps_current
        )

        if not vehicle_movement.is_valid:
            # Return empty predictions - fall back to existing tracking
            return predictions

        # Calculate screen displacement
        screen_displacement = self.screen_predictor.predict_screen_displacement(
            vehicle_movement
        )

        if screen_displacement.confidence < 0.3:
            # Low confidence - don't use predictions
            return predictions

        # Apply displacement to each tracked object
        for track_id, last_position in current_track_positions.items():
            predicted_position = np.array(
                [
                    last_position[0] + screen_displacement.displacement_x_px,
                    last_position[1] + screen_displacement.displacement_y_px,
                ]
            )

            # Store prediction info
            predictions[track_id] = {
                "predicted_position": predicted_position,
                "last_position": last_position,
                "displacement": np.array(
                    [
                        screen_displacement.displacement_x_px,
                        screen_displacement.displacement_y_px,
                    ]
                ),
                "confidence": screen_displacement.confidence,
                "vehicle_movement": vehicle_movement,
                "screen_displacement": screen_displacement,
            }

            self.prediction_count += 1

        if self.config.enable_debug_logging and predictions:
            self.logger.debug(
                f"Generated {len(predictions)} position predictions with "
                f"confidence {screen_displacement.confidence:.2f}"
            )

        return predictions

    def get_prediction_statistics(self) -> Dict:
        """Get motion prediction statistics"""
        success_rate = (
            self.successful_predictions / max(1, self.prediction_count)
        ) * 100
        avg_error = self.total_prediction_error / max(1, self.successful_predictions)

        return {
            "total_predictions": self.prediction_count,
            "successful_predictions": self.successful_predictions,
            "success_rate_percent": success_rate,
            "average_prediction_error_px": avg_error,
            "gps_smoothing_window": self.config.gps_smoothing_window,
            "object_distance_m": self.config.default_object_distance_m,
        }

    def update_prediction_accuracy(self, prediction_error_px: float):
        """Update prediction accuracy statistics"""
        self.successful_predictions += 1
        self.total_prediction_error += prediction_error_px


def create_motion_prediction_config(
    object_distance_m: float = 30.0,
    gps_accuracy_threshold_m: float = 3.0,
    prediction_tolerance_px: float = 15.0,
    enable_debug: bool = True,
) -> MotionPredictionConfig:
    """
    Create motion prediction configuration with common parameters

    Args:
        object_distance_m: Assumed distance to objects in meters
        gps_accuracy_threshold_m: GPS accuracy threshold for using predictions
        prediction_tolerance_px: Tolerance for matching predictions to detections
        enable_debug: Enable debug logging and visualization

    Returns:
        MotionPredictionConfig object
    """
    return MotionPredictionConfig(
        default_object_distance_m=object_distance_m,
        min_gps_accuracy_m=gps_accuracy_threshold_m,
        max_gps_accuracy_m=gps_accuracy_threshold_m + 2.0,
        prediction_tolerance_px=prediction_tolerance_px,
        enable_debug_logging=enable_debug,
        enable_prediction_visualization=enable_debug,
    )

================
File: argus_track/utils/gps_sync_tracker.py
================
"""
GPS-synchronized frame processing implementation for Argus Track
FIXED: Only process frames when GPS data is actually available
"""

import logging
from typing import Any, Dict, List, Optional, Set

import numpy as np

from ..core import GPSData

# Configure logging
logger = logging.getLogger(__name__)


class GPSSynchronizer:
    """
    Synchronizes video frame processing with actual GPS data points
    ONLY processes frames that have real GPS measurements
    """

    def __init__(
        self, gps_data: List[GPSData], video_fps: float, gps_fps: float = 10.0
    ):
        """
        Initialize GPS synchronizer - FIXED VERSION

        Args:
            gps_data: List of actual GPS data points
            video_fps: Video frame rate in FPS
            gps_fps: Expected GPS data rate in Hz (for validation only)
        """
        if not gps_data:
            self.gps_data = []
            self.sync_frames = set()
            self.frame_to_gps = {}
            return

        self.gps_data = sorted(gps_data, key=lambda x: x.timestamp)
        self.video_fps = video_fps
        self.gps_fps = gps_fps

        # Calculate video start time (assume GPS and video start together)
        self.video_start_time = self.gps_data[0].timestamp

        # FIXED: Only create mappings for frames where we have actual GPS data
        self.frame_to_gps: Dict[int, int] = {}  # frame_idx -> gps_data_idx
        self.sync_frames: Set[int] = set()  # Only frames with GPS data

        # Generate the mapping - ONLY for actual GPS points
        self._generate_gps_frame_mapping()

        logger.info(f"GPS Synchronizer initialized:")
        logger.info(f"  ðŸ“Š GPS points available: {len(self.gps_data)}")
        logger.info(f"  ðŸŽ¬ Video FPS: {video_fps}")
        logger.info(f"  ðŸ“ Frames to process: {len(self.sync_frames)}")
        logger.info(
            f"  â±ï¸  Processing ratio: {len(self.sync_frames)}/{int(video_fps * self._get_video_duration()):.0f} frames"
        )

    def _get_video_duration(self) -> float:
        """Calculate video duration based on GPS data"""
        if len(self.gps_data) < 2:
            return 0.0
        return self.gps_data[-1].timestamp - self.gps_data[0].timestamp

    def _generate_gps_frame_mapping(self) -> None:
        """Generate mapping ONLY for frames with actual GPS data"""
        if not self.gps_data:
            return

        for gps_idx, gps_point in enumerate(self.gps_data):
            # Calculate which video frame corresponds to this GPS timestamp
            time_offset = gps_point.timestamp - self.video_start_time
            frame_number = int(time_offset * self.video_fps)

            # Only map frames that are valid
            if frame_number >= 0:
                self.frame_to_gps[frame_number] = gps_idx
                self.sync_frames.add(frame_number)

        logger.info(f"GPS-Video Mapping:")
        logger.info(f"  ðŸ“ GPS points: {len(self.gps_data)}")
        logger.info(f"  ðŸŽ¬ Mapped frames: {len(self.sync_frames)}")

        if self.sync_frames:
            min_frame = min(self.sync_frames)
            max_frame = max(self.sync_frames)
            logger.info(f"  ðŸ“Š Frame range: {min_frame} to {max_frame}")

            # Show actual GPS frequency
            frame_intervals = []
            sorted_frames = sorted(self.sync_frames)
            for i in range(1, len(sorted_frames)):
                interval = sorted_frames[i] - sorted_frames[i - 1]
                frame_intervals.append(interval)

            if frame_intervals:
                avg_interval = np.mean(frame_intervals)
                actual_gps_freq = (
                    self.video_fps / avg_interval if avg_interval > 0 else 0
                )
                logger.info(f"  ðŸ”„ Actual GPS frequency: {actual_gps_freq:.1f} Hz")
                logger.info(f"  ðŸ“ Average frame interval: {avg_interval:.1f} frames")

    def should_process_frame(self, frame_idx: int) -> bool:
        """
        FIXED: Only process frames that have actual GPS data

        Args:
            frame_idx: Frame index

        Returns:
            True ONLY if frame has GPS data, False otherwise
        """
        return frame_idx in self.sync_frames

    def get_gps_for_frame(self, frame_idx: int) -> Optional[GPSData]:
        """
        Get GPS data for a specific frame

        Args:
            frame_idx: Frame index

        Returns:
            GPS data for the frame or None if not available
        """
        gps_idx = self.frame_to_gps.get(frame_idx)
        if gps_idx is not None and gps_idx < len(self.gps_data):
            return self.gps_data[gps_idx]
        return None

    def get_all_sync_frames(self) -> List[int]:
        """
        Get all frames that should be processed (only GPS frames)

        Returns:
            Sorted list of frame indices with GPS data
        """
        return sorted(list(self.sync_frames))

    def get_sync_frames_count(self) -> int:
        """
        Get number of frames to process (only GPS frames)

        Returns:
            Number of frames with GPS data
        """
        return len(self.sync_frames)

    def get_next_sync_frame(self, current_frame: int) -> Optional[int]:
        """
        Get the next frame with GPS data

        Args:
            current_frame: Current frame index

        Returns:
            Next frame index with GPS data or None if no more
        """
        sync_frames = sorted(list(self.sync_frames))
        for frame in sync_frames:
            if frame > current_frame:
                return frame
        return None

    def get_processing_statistics(self) -> Dict[str, Any]:
        """
        Get statistics about GPS-synchronized processing

        Returns:
            Dictionary with processing statistics
        """
        if not self.sync_frames:
            return {
                "gps_points": 0,
                "sync_frames": 0,
                "processing_ratio": 0.0,
                "avg_gps_frequency": 0.0,
            }

        sync_frames = sorted(list(self.sync_frames))
        frame_intervals = np.diff(sync_frames) if len(sync_frames) > 1 else [0]

        avg_interval = np.mean(frame_intervals) if len(frame_intervals) > 0 else 0
        actual_gps_freq = self.video_fps / avg_interval if avg_interval > 0 else 0

        # Calculate total video frames in the GPS time range
        if len(sync_frames) >= 2:
            frame_span = max(sync_frames) - min(sync_frames)
            processing_ratio = (
                len(sync_frames) / (frame_span + 1) if frame_span > 0 else 1.0
            )
        else:
            processing_ratio = 1.0 if sync_frames else 0.0

        return {
            "gps_points": len(self.gps_data),
            "sync_frames": len(self.sync_frames),
            "processing_ratio": processing_ratio,
            "avg_gps_frequency": actual_gps_freq,
            "frame_range": (
                (min(sync_frames), max(sync_frames)) if sync_frames else (0, 0)
            ),
            "avg_frame_interval": avg_interval,
        }


def create_gps_synchronizer(
    gps_data: List[GPSData], video_fps: float, gps_fps: float = 10.0
) -> GPSSynchronizer:
    """
    Create a GPS synchronizer for frame processing
    FIXED: Only processes frames with actual GPS data

    Args:
        gps_data: List of actual GPS data points
        video_fps: Video frame rate in FPS
        gps_fps: Expected GPS data rate in Hz (for validation)

    Returns:
        GPS synchronizer instance
    """
    return GPSSynchronizer(gps_data, video_fps, gps_fps)

================
File: argus_track/utils/gps_utils.py
================
# argus_track/utils/gps_utils.py

"""Enhanced GPS utilities for tracking"""

from dataclasses import dataclass
from typing import List, Optional, Tuple

import numpy as np
import pyproj
from scipy.interpolate import interp1d

from ..core import GPSData


class GPSInterpolator:
    """Interpolate GPS data between frames"""

    def __init__(self, gps_data: List[GPSData]):
        """
        Initialize GPS interpolator

        Args:
            gps_data: List of GPS data points
        """
        self.gps_data = sorted(gps_data, key=lambda x: x.timestamp)
        self.timestamps = np.array([gps.timestamp for gps in self.gps_data])

        # Create interpolation functions
        self.lat_interp = interp1d(
            self.timestamps,
            [gps.latitude for gps in self.gps_data],
            kind="linear",
            fill_value="extrapolate",
        )
        self.lon_interp = interp1d(
            self.timestamps,
            [gps.longitude for gps in self.gps_data],
            kind="linear",
            fill_value="extrapolate",
        )
        self.heading_interp = interp1d(
            self.timestamps,
            [gps.heading for gps in self.gps_data],
            kind="linear",
            fill_value="extrapolate",
        )

    def interpolate(self, timestamp: float) -> GPSData:
        """
        Interpolate GPS data for a specific timestamp

        Args:
            timestamp: Target timestamp

        Returns:
            Interpolated GPS data
        """
        return GPSData(
            timestamp=timestamp,
            latitude=float(self.lat_interp(timestamp)),
            longitude=float(self.lon_interp(timestamp)),
            altitude=0.0,  # We're not focusing on altitude
            heading=float(self.heading_interp(timestamp)),
            accuracy=1.0,  # Interpolated accuracy
        )

    def get_range(self) -> Tuple[float, float]:
        """Get timestamp range of GPS data"""
        return self.timestamps[0], self.timestamps[-1]


class CoordinateTransformer:
    """Transform between GPS coordinates and local coordinate systems"""

    def __init__(self, reference_lat: float, reference_lon: float):
        """
        Initialize transformer with reference point

        Args:
            reference_lat: Reference latitude
            reference_lon: Reference longitude
        """
        self.reference_lat = reference_lat
        self.reference_lon = reference_lon

        # Setup projections
        self.wgs84 = pyproj.CRS("EPSG:4326")  # GPS coordinates
        self.utm = pyproj.CRS(f"EPSG:{self._get_utm_zone()}")
        self.transformer = pyproj.Transformer.from_crs(
            self.wgs84, self.utm, always_xy=True
        )
        self.inverse_transformer = pyproj.Transformer.from_crs(
            self.utm, self.wgs84, always_xy=True
        )

        # Calculate reference point in UTM
        self.ref_x, self.ref_y = self.transformer.transform(
            reference_lon, reference_lat
        )

    def _get_utm_zone(self) -> int:
        """Get UTM zone for reference point"""
        zone = int((self.reference_lon + 180) / 6) + 1
        if self.reference_lat >= 0:
            return 32600 + zone  # Northern hemisphere
        else:
            return 32700 + zone  # Southern hemisphere

    def gps_to_local(self, lat: float, lon: float) -> Tuple[float, float]:
        """
        Convert GPS coordinates to local coordinate system

        Args:
            lat: Latitude
            lon: Longitude

        Returns:
            (x, y) in meters from reference point
        """
        utm_x, utm_y = self.transformer.transform(lon, lat)
        return utm_x - self.ref_x, utm_y - self.ref_y

    def local_to_gps(self, x: float, y: float) -> Tuple[float, float]:
        """
        Convert local coordinates to GPS

        Args:
            x: X coordinate in meters from reference
            y: Y coordinate in meters from reference

        Returns:
            (latitude, longitude)
        """
        utm_x = x + self.ref_x
        utm_y = y + self.ref_y
        lon, lat = self.inverse_transformer.transform(utm_x, utm_y)
        return lat, lon

    def distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -> float:
        """
        Calculate distance between two GPS points

        Args:
            lat1, lon1: First point
            lat2, lon2: Second point

        Returns:
            Distance in meters
        """
        x1, y1 = self.gps_to_local(lat1, lon1)
        x2, y2 = self.gps_to_local(lat2, lon2)
        return np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)


@dataclass
class GeoLocation:
    """Represents a geographic location with reliability information"""

    latitude: float
    longitude: float
    accuracy: float = 1.0  # Accuracy in meters
    reliability: float = 1.0  # Value between 0 and 1
    timestamp: Optional[float] = None


def sync_gps_with_frames(
    gps_data: List[GPSData], video_fps: float, start_timestamp: Optional[float] = None
) -> List[GPSData]:
    """
    Synchronize GPS data with video frames

    Args:
        gps_data: List of GPS data points
        video_fps: Video frame rate
        start_timestamp: Optional start timestamp

    Returns:
        List of GPS data aligned with frames
    """
    if not gps_data:
        return []

    # Sort GPS data by timestamp
    gps_data = sorted(gps_data, key=lambda x: x.timestamp)

    # Determine start timestamp
    if start_timestamp is None:
        start_timestamp = gps_data[0].timestamp

    # Create interpolator
    interpolator = GPSInterpolator(gps_data)

    # Generate frame-aligned GPS data
    frame_gps = []
    frame_duration = 1.0 / video_fps

    timestamp = start_timestamp
    while timestamp <= gps_data[-1].timestamp:
        frame_gps.append(interpolator.interpolate(timestamp))
        timestamp += frame_duration

    return frame_gps


def compute_average_location(locations: List[GPSData]) -> GeoLocation:
    """
    Compute the average location from multiple GPS points

    Args:
        locations: List of GPS data points

    Returns:
        Average location with reliability score
    """
    if not locations:
        return GeoLocation(0.0, 0.0, 0.0, 0.0)

    # Simple weighted average based on accuracy
    weights = np.array([1.0 / max(loc.accuracy, 0.1) for loc in locations])
    weights = weights / np.sum(weights)  # Normalize

    avg_lat = np.sum([loc.latitude * w for loc, w in zip(locations, weights)])
    avg_lon = np.sum([loc.longitude * w for loc, w in zip(locations, weights)])

    # Calculate reliability based on consistency of points
    if len(locations) > 1:
        # Create transformer using the first point as reference
        transformer = CoordinateTransformer(
            locations[0].latitude, locations[0].longitude
        )

        # Calculate standard deviation in meters
        distances = []
        for loc in locations:
            dist = transformer.distance(loc.latitude, loc.longitude, avg_lat, avg_lon)
            distances.append(dist)

        std_dev = np.std(distances)
        reliability = 1.0 / (
            1.0 + std_dev / 10.0
        )  # Decreases with higher standard deviation
        reliability = min(1.0, max(0.1, reliability))  # Clamp between 0.1 and 1.0
    else:
        reliability = 0.5  # Only one point, medium reliability

    # Average accuracy is the weighted average of individual accuracies
    avg_accuracy = np.sum([loc.accuracy * w for loc, w in zip(locations, weights)])

    # Use the latest timestamp
    latest_timestamp = max([loc.timestamp for loc in locations])

    return GeoLocation(
        latitude=avg_lat,
        longitude=avg_lon,
        accuracy=avg_accuracy,
        reliability=reliability,
        timestamp=latest_timestamp,
    )


def filter_gps_outliers(
    locations: List[GPSData], threshold_meters: float = 30.0
) -> List[GPSData]:
    """
    Filter outliers from GPS data using DBSCAN clustering

    Args:
        locations: List of GPS data points
        threshold_meters: Distance threshold for outlier detection

    Returns:
        Filtered list of GPS data points
    """
    if len(locations) <= 2:
        return locations

    from sklearn.cluster import DBSCAN

    # Create transformer using the first point as reference
    transformer = CoordinateTransformer(locations[0].latitude, locations[0].longitude)

    # Convert to local coordinates
    local_points = []
    for loc in locations:
        x, y = transformer.gps_to_local(loc.latitude, loc.longitude)
        local_points.append([x, y])

    # Cluster points
    clustering = DBSCAN(eps=threshold_meters, min_samples=1).fit(local_points)

    # Find the largest cluster
    labels = clustering.labels_
    unique_labels, counts = np.unique(labels, return_counts=True)
    largest_cluster = unique_labels[np.argmax(counts)]

    # Keep only points from the largest cluster
    filtered_locations = [
        loc for i, loc in enumerate(locations) if labels[i] == largest_cluster
    ]

    return filtered_locations

================
File: argus_track/utils/io.py
================
# argus_track/utils/io.py

"""I/O utilities for loading and saving tracking data"""

import csv
import json
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional


from ..core import GPSData, Track


def setup_logging(log_file: Optional[str] = None, level: int = logging.INFO) -> None:
    """
    Setup logging configuration

    Args:
        log_file: Optional log file path
        level: Logging level
    """
    handlers = [logging.StreamHandler()]

    if log_file:
        handlers.append(logging.FileHandler(log_file))

    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=handlers,
    )


def save_tracking_results(
    tracks: Dict[int, List[Dict]],
    output_path: Path,
    metadata: Optional[Dict[str, Any]] = None,
    gps_tracks: Optional[Dict[int, List[GPSData]]] = None,
    track_locations: Optional[Dict[int, Dict]] = None,
) -> None:
    """
    Save tracking results to JSON file

    Args:
        tracks: Dictionary of track histories
        output_path: Path for output file
        metadata: Optional metadata to include
        gps_tracks: Optional GPS data for tracks
        track_locations: Optional estimated locations for tracks
    """
    results = {"metadata": metadata or {}, "tracks": tracks}

    # Add GPS data if provided
    if gps_tracks:
        results["gps_tracks"] = {
            track_id: [gps.to_dict() for gps in gps_list]
            for track_id, gps_list in gps_tracks.items()
        }

    # Add track locations if provided
    if track_locations:
        results["track_locations"] = track_locations

    # Save to file
    with open(output_path, "w") as f:
        json.dump(results, f, indent=2)

    logging.info(f"Saved tracking results to {output_path}")


def load_tracking_results(input_path: Path) -> Dict[str, Any]:
    """
    Load tracking results from JSON file

    Args:
        input_path: Path to input file

    Returns:
        Dictionary with tracking results
    """
    with open(input_path, "r") as f:
        results = json.load(f)

    logging.info(f"Loaded tracking results from {input_path}")
    return results


def load_gps_data(gps_file: str) -> List[GPSData]:
    """
    Load GPS data from file

    Args:
        gps_file: Path to GPS data file (CSV format)

    Returns:
        List of GPS data points
    """
    gps_data = []

    with open(gps_file, "r") as f:
        reader = csv.reader(f)
        # Skip header if exists
        next(reader, None)

        try:
            for row in reader:
                if len(row) >= 5:
                    gps_data.append(
                        GPSData(
                            timestamp=float(row[0]),
                            latitude=float(row[1]),
                            longitude=float(row[2]),
                            altitude=float(row[3]) if len(row) > 3 else 0.0,
                            heading=float(row[4]) if len(row) > 4 else 0.0,
                            accuracy=float(row[5]) if len(row) > 5 else 1.0,
                        )
                    )
        except ValueError as e:
            logging.error(f"Error parsing GPS data: {e}")
            logging.error(f"Problematic row: {row}")
            raise

    logging.info(f"Loaded {len(gps_data)} GPS data points from {gps_file}")
    return gps_data


def save_gps_data(gps_data: List[GPSData], output_path: str) -> None:
    """
    Save GPS data to CSV file

    Args:
        gps_data: List of GPS data points
        output_path: Path for output file
    """
    with open(output_path, "w", newline="") as f:
        writer = csv.writer(f)
        # Write header
        writer.writerow(
            ["timestamp", "latitude", "longitude", "altitude", "heading", "accuracy"]
        )

        # Write data
        for gps in gps_data:
            writer.writerow(
                [
                    gps.timestamp,
                    gps.latitude,
                    gps.longitude,
                    gps.altitude,
                    gps.heading,
                    gps.accuracy,
                ]
            )

    logging.info(f"Saved {len(gps_data)} GPS data points to {output_path}")


def export_locations_to_csv(track_locations: Dict[int, Dict], output_path: str) -> None:
    """
    Export estimated track locations to CSV

    Args:
        track_locations: Dictionary of track locations
        output_path: Output CSV path
    """
    with open(output_path, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(
            [
                "track_id",
                "latitude",
                "longitude",
                "accuracy",
                "reliability",
                "timestamp",
            ]
        )

        for track_id, location in track_locations.items():
            writer.writerow(
                [
                    track_id,
                    location["latitude"],
                    location["longitude"],
                    location.get("accuracy", 1.0),
                    location.get("reliability", 1.0),
                    location.get("timestamp", ""),
                ]
            )

    logging.info(f"Exported {len(track_locations)} locations to CSV: {output_path}")


def export_tracks_to_csv(tracks: Dict[int, Track], output_path: str) -> None:
    """
    Export track data to CSV format

    Args:
        tracks: Dictionary of tracks
        output_path: Path for output CSV file
    """
    with open(output_path, "w", newline="") as f:
        writer = csv.writer(f)
        # Write header
        writer.writerow(
            ["track_id", "frame", "x1", "y1", "x2", "y2", "state", "hits", "age"]
        )

        # Write track data
        for track_id, track in tracks.items():
            for detection in track.detections:
                x1, y1, x2, y2 = detection.tlbr
                writer.writerow(
                    [
                        track_id,
                        detection.frame_id,
                        x1,
                        y1,
                        x2,
                        y2,
                        track.state,
                        track.hits,
                        track.age,
                    ]
                )

    logging.info(f"Exported tracks to CSV: {output_path}")


def load_config_from_file(config_path: str) -> Dict[str, Any]:
    """
    Load configuration from YAML or JSON file

    Args:
        config_path: Path to configuration file

    Returns:
        Configuration dictionary
    """
    path = Path(config_path)

    # argus_track/utils/io.py (continued)

    if path.suffix == ".yaml" or path.suffix == ".yml":
        import yaml

        with open(config_path, "r") as f:
            config = yaml.safe_load(f)
    elif path.suffix == ".json":
        with open(config_path, "r") as f:
            config = json.load(f)
    else:
        raise ValueError(f"Unsupported config file format: {path.suffix}")

    logging.info(f"Loaded configuration from {config_path}")
    return config


def export_to_geojson(
    track_locations: Dict[int, Dict],
    output_path: str,
    properties: Optional[Dict[int, Dict]] = None,
) -> None:
    """
    Export track locations to GeoJSON format

    Args:
        track_locations: Dictionary of track locations
        output_path: Path for output GeoJSON file
        properties: Optional additional properties for each feature
    """
    features = []

    for track_id, location in track_locations.items():
        # Create basic properties
        feature_props = {
            "track_id": track_id,
            "accuracy": location.get("accuracy", 1.0),
            "reliability": location.get("reliability", 1.0),
        }

        # Add additional properties if provided
        if properties and track_id in properties:
            feature_props.update(properties[track_id])

        feature = {
            "type": "Feature",
            "geometry": {
                "type": "Point",
                "coordinates": [location["longitude"], location["latitude"]],
            },
            "properties": feature_props,
        }

        features.append(feature)

    geojson = {"type": "FeatureCollection", "features": features}

    with open(output_path, "w") as f:
        json.dump(geojson, f, indent=2)

    logging.info(f"Exported {len(features)} locations to GeoJSON: {output_path}")

================
File: argus_track/utils/iou.py
================
# argus_track/utils/iou.py

"""IoU (Intersection over Union) utilities for tracking"""

from typing import List, Union

import numpy as np
from numba import jit

from ..core import Detection, Track


@jit(nopython=True)
def calculate_iou_jit(bbox1: np.ndarray, bbox2: np.ndarray) -> float:
    """
    Calculate IoU between two bounding boxes (numba accelerated)

    Args:
        bbox1: First bbox in [x1, y1, x2, y2] format
        bbox2: Second bbox in [x1, y1, x2, y2] format

    Returns:
        IoU value between 0 and 1
    """
    # Get intersection coordinates
    x1 = max(bbox1[0], bbox2[0])
    y1 = max(bbox1[1], bbox2[1])
    x2 = min(bbox1[2], bbox2[2])
    y2 = min(bbox1[3], bbox2[3])

    # Calculate intersection area
    intersection_area = max(0, x2 - x1) * max(0, y2 - y1)

    # Calculate union area
    bbox1_area = (bbox1[2] - bbox1[0]) * (bbox1[3] - bbox1[1])
    bbox2_area = (bbox2[2] - bbox2[0]) * (bbox2[3] - bbox2[1])
    union_area = bbox1_area + bbox2_area - intersection_area

    # Avoid division by zero
    if union_area == 0:
        return 0.0

    return intersection_area / union_area


def calculate_iou(bbox1: np.ndarray, bbox2: np.ndarray) -> float:
    """
    Calculate IoU between two bounding boxes

    Args:
        bbox1: First bbox in [x1, y1, x2, y2] format
        bbox2: Second bbox in [x1, y1, x2, y2] format

    Returns:
        IoU value between 0 and 1
    """
    return calculate_iou_jit(bbox1, bbox2)


@jit(nopython=True)
def calculate_iou_matrix_jit(bboxes1: np.ndarray, bboxes2: np.ndarray) -> np.ndarray:
    """
    Calculate IoU matrix between two sets of bounding boxes (numba accelerated)

    Args:
        bboxes1: First set of bboxes in [N, 4] format
        bboxes2: Second set of bboxes in [M, 4] format

    Returns:
        IoU matrix of shape [N, M]
    """
    n_bbox1 = bboxes1.shape[0]
    n_bbox2 = bboxes2.shape[0]
    iou_matrix = np.zeros((n_bbox1, n_bbox2))

    for i in range(n_bbox1):
        for j in range(n_bbox2):
            iou_matrix[i, j] = calculate_iou_jit(bboxes1[i], bboxes2[j])

    return iou_matrix


def calculate_iou_matrix(
    tracks_or_bboxes1: Union[List[Track], np.ndarray],
    detections_or_bboxes2: Union[List[Detection], np.ndarray],
) -> np.ndarray:
    """
    Calculate IoU matrix between tracks and detections

    Args:
        tracks_or_bboxes1: List of tracks or array of bboxes
        detections_or_bboxes2: List of detections or array of bboxes

    Returns:
        IoU matrix of shape (len(tracks_or_bboxes1), len(detections_or_bboxes2))
    """
    # Handle different input types
    if isinstance(tracks_or_bboxes1, np.ndarray):
        bboxes1 = tracks_or_bboxes1
    else:
        bboxes1 = np.array([track.to_tlbr() for track in tracks_or_bboxes1])

    if isinstance(detections_or_bboxes2, np.ndarray):
        bboxes2 = detections_or_bboxes2
    else:
        bboxes2 = np.array([det.tlbr for det in detections_or_bboxes2])

    # Calculate IoU matrix
    return calculate_iou_matrix_jit(bboxes1, bboxes2)

================
File: argus_track/utils/output_manager.py
================
# argus_track/utils/output_manager.py (NEW FILE)

"""
Output Manager - Handles JSON and CSV export for simplified tracking
"""

import csv
import json
import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional

from ..core import Detection, GPSData


@dataclass
class FrameData:
    """Data for a single processed frame"""

    frame_id: int
    timestamp: float
    detections: List[Detection]
    gps_data: Optional[GPSData] = None


class OutputManager:
    """
    Manages output file generation for simplified tracking

    Outputs:
    1. JSON file: Frame-by-frame detection data
    2. CSV file: GPS data synchronized with frame IDs
    """

    def __init__(self, video_path: str, class_names: List[str]):
        """
        Initialize output manager

        Args:
            video_path: Path to input video (for output naming)
            class_names: List of class names from YOLO model
        """
        self.video_path = Path(video_path)
        self.class_names = class_names
        self.logger = logging.getLogger(f"{__name__}.OutputManager")

        # Storage for output data
        self.frame_data: Dict[int, FrameData] = {}
        self.processing_stats = {
            "total_frames_processed": 0,
            "total_detections": 0,
            "unique_track_ids": set(),
            "class_distribution": {},
            "processing_time": 0.0,
        }

        self.logger.info(f"Output Manager initialized for video: {video_path}")
        self.logger.info(f"Available classes: {class_names}")

    def add_frame_data(
        self,
        frame_id: int,
        timestamp: float,
        detections: List[Detection],
        gps_data: Optional[GPSData] = None,
    ):
        """
        Add data for a processed frame

        Args:
            frame_id: Frame identifier
            timestamp: Timestamp in original video
            detections: List of detections for this frame
            gps_data: GPS data for this frame (if available)
        """
        self.frame_data[frame_id] = FrameData(
            frame_id=frame_id,
            timestamp=timestamp,
            detections=detections.copy() if detections else [],
            gps_data=gps_data,
        )

        # Update statistics
        self.processing_stats["total_frames_processed"] += 1
        self.processing_stats["total_detections"] += (
            len(detections) if detections else 0
        )

        for detection in detections or []:
            self.processing_stats["unique_track_ids"].add(detection.track_id)

            # Update class distribution
            class_name = self._get_class_name(detection.class_id)
            if class_name not in self.processing_stats["class_distribution"]:
                self.processing_stats["class_distribution"][class_name] = 0
            self.processing_stats["class_distribution"][class_name] += 1

    def export_json(self, output_path: Optional[str] = None) -> str:
        """
        Export frame data to JSON file

        Args:
            output_path: Custom output path (optional)

        Returns:
            Path to exported JSON file
        """
        if output_path is None:
            output_path = self.video_path.with_suffix(".json")

        # Prepare JSON data
        json_data = {
            "metadata": {
                "video_file": str(self.video_path),
                "total_frames": self.processing_stats["total_frames_processed"],
                "total_detections": self.processing_stats["total_detections"],
                "unique_tracks": len(self.processing_stats["unique_track_ids"]),
                "class_names": self.class_names,
                "class_distribution": self.processing_stats["class_distribution"],
                "processing_method": "simplified_tracking_with_consolidation",
            },
            "frames": {},
        }

        # Add frame data
        for frame_id, data in sorted(self.frame_data.items()):
            frame_key = f"frame_{frame_id}"
            json_data["frames"][frame_key] = {
                "timestamp": data.timestamp,
                "detections": [
                    {
                        "track_id": det.track_id,
                        "class": self._get_class_name(det.class_id),
                        "class_id": det.class_id,
                        "bbox": [
                            float(det.bbox[0]),  # x1
                            float(det.bbox[1]),  # y1
                            float(det.bbox[2]),  # x2
                            float(det.bbox[3]),  # y2
                        ],
                        "confidence": float(det.score),
                    }
                    for det in data.detections
                ],
            }

        # Write JSON file
        with open(output_path, "w") as f:
            json.dump(json_data, f, indent=2)

        self.logger.info(f"ðŸ“„ Exported frame data to JSON: {output_path}")
        self.logger.info(f"   Frames: {len(self.frame_data)}")
        self.logger.info(
            f"   Total detections: {self.processing_stats['total_detections']}"
        )
        self.logger.info(
            f"   Unique tracks: {len(self.processing_stats['unique_track_ids'])}"
        )

        return str(output_path)

    def export_csv(self, output_path: Optional[str] = None) -> str:
        """
        Export GPS data to CSV file

        Args:
            output_path: Custom output path (optional)

        Returns:
            Path to exported CSV file
        """
        if output_path is None:
            output_path = self.video_path.with_suffix(".csv")

        # Collect GPS data with frame IDs
        gps_rows = []
        for frame_id, data in sorted(self.frame_data.items()):
            if data.gps_data is not None:
                gps_rows.append(
                    {
                        "frame_id": frame_id,
                        "timestamp": data.timestamp,
                        "latitude": data.gps_data.latitude,
                        "longitude": data.gps_data.longitude,
                        "altitude": data.gps_data.altitude,
                        "heading": data.gps_data.heading,
                        "accuracy": data.gps_data.accuracy,
                    }
                )

        # Write CSV file
        if gps_rows:
            with open(output_path, "w", newline="") as f:
                fieldnames = [
                    "frame_id",
                    "timestamp",
                    "latitude",
                    "longitude",
                    "altitude",
                    "heading",
                    "accuracy",
                ]
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(gps_rows)

            self.logger.info(f"ðŸ“ Exported GPS data to CSV: {output_path}")
            self.logger.info(f"   GPS entries: {len(gps_rows)}")
        else:
            # Create empty CSV with headers
            with open(output_path, "w", newline="") as f:
                fieldnames = [
                    "frame_id",
                    "timestamp",
                    "latitude",
                    "longitude",
                    "altitude",
                    "heading",
                    "accuracy",
                ]
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()

            self.logger.warning(
                f"âš ï¸  No GPS data available - created empty CSV: {output_path}"
            )

        return str(output_path)

    def export_both(
        self, json_path: Optional[str] = None, csv_path: Optional[str] = None
    ) -> tuple[str, str]:
        """
        Export both JSON and CSV files

        Args:
            json_path: Custom JSON output path (optional)
            csv_path: Custom CSV output path (optional)

        Returns:
            Tuple of (json_path, csv_path)
        """
        json_output = self.export_json(json_path)
        csv_output = self.export_csv(csv_path)

        return json_output, csv_output

    def _get_class_name(self, class_id: int) -> str:
        """Get class name from class ID"""
        if 0 <= class_id < len(self.class_names):
            return self.class_names[class_id]
        else:
            return f"unknown_class_{class_id}"

    def get_processing_summary(self) -> Dict[str, Any]:
        """Get processing summary statistics"""
        return {
            "frames_processed": self.processing_stats["total_frames_processed"],
            "total_detections": self.processing_stats["total_detections"],
            "unique_tracks": len(self.processing_stats["unique_track_ids"]),
            "avg_detections_per_frame": (
                self.processing_stats["total_detections"]
                / max(1, self.processing_stats["total_frames_processed"])
            ),
            "class_distribution": dict(self.processing_stats["class_distribution"]),
            "frames_with_gps": len(
                [data for data in self.frame_data.values() if data.gps_data is not None]
            ),
        }

    def print_summary(self):
        """Print processing summary to console"""
        summary = self.get_processing_summary()

        print("\n" + "=" * 50)
        print("ðŸ“Š PROCESSING SUMMARY")
        print("=" * 50)
        print(f"ðŸ“¹ Video: {self.video_path.name}")
        print(f"ðŸŽ¬ Frames processed: {summary['frames_processed']}")
        print(f"ðŸŽ¯ Total detections: {summary['total_detections']}")
        print(f"ðŸ·ï¸  Unique tracks: {summary['unique_tracks']}")
        print(f"ðŸ“Š Avg detections/frame: {summary['avg_detections_per_frame']:.1f}")
        print(f"ðŸ“ Frames with GPS: {summary['frames_with_gps']}")

        if summary["class_distribution"]:
            print("\nðŸ·ï¸  Class Distribution:")
            for class_name, count in summary["class_distribution"].items():
                print(f"   {class_name}: {count}")

        print("=" * 50)

    def create_sample_output(self) -> Dict[str, Any]:
        """Create sample output structure for documentation"""
        return {
            "sample_json_structure": {
                "metadata": {
                    "video_file": "example_video.mp4",
                    "total_frames": 150,
                    "total_detections": 45,
                    "unique_tracks": 8,
                    "class_names": ["LED", "traffic_light", "street_lamp"],
                    "class_distribution": {"LED": 30, "traffic_light": 15},
                },
                "frames": {
                    "frame_6": {
                        "timestamp": 0.1,
                        "detections": [
                            {
                                "track_id": 1,
                                "class": "LED",
                                "class_id": 0,
                                "bbox": [100.5, 200.3, 150.8, 280.1],
                                "confidence": 0.85,
                            }
                        ],
                    }
                },
            },
            "sample_csv_structure": [
                {
                    "frame_id": 6,
                    "timestamp": 0.1,
                    "latitude": -34.758432,
                    "longitude": -58.635219,
                    "altitude": 25.4,
                    "heading": 45.2,
                    "accuracy": 1.0,
                }
            ],
        }

================
File: argus_track/utils/static_car_detector.py
================
# argus_track/utils/static_car_detector.py - NEW FILE

"""
Static Car Detector - Skip frames when GPS position doesn't change
"""

import logging
from dataclasses import dataclass
from typing import List, Optional

import numpy as np

from ..core import GPSData


@dataclass
class StaticCarConfig:
    """Configuration for static car detection"""

    movement_threshold_meters: float = 2.0  # Minimum movement to consider as "moving"
    stationary_time_threshold: float = 10.0  # Seconds before considering stationary
    gps_frame_interval: int = 6  # Normal GPS frame processing interval


class StaticCarDetector:
    """
    Detects when car is stationary and skips frames for processing efficiency

    Logic:
    1. Car stops moving (< 2m movement for 10+ seconds) â†’ Skip all frames
    2. Car starts moving again â†’ Resume normal frame processing
    3. Purpose: Speed up processing, we already captured objects when we first stopped
    """

    def __init__(self, config: StaticCarConfig):
        """
        Initialize static car detector

        Args:
            config: Static car detection configuration
        """
        self.config = config
        self.logger = logging.getLogger(f"{__name__}.StaticCarDetector")

        # State tracking
        self.gps_history: List[GPSData] = []
        self.last_movement_time: float = 0.0
        self.is_currently_stationary: bool = False
        self.total_frames_processed: int = 0
        self.total_frames_skipped: int = 0

        # Statistics
        self.stationary_periods: List[float] = []  # Duration of each stationary period
        self.current_stationary_start: Optional[float] = None

        self.logger.info(f"Static Car Detector initialized:")
        self.logger.info(f"  Movement threshold: {config.movement_threshold_meters}m")
        self.logger.info(f"  Stationary threshold: {config.stationary_time_threshold}s")

    def should_process_frame(self, gps_data: GPSData, frame_id: int) -> bool:
        """
        Determine if frame should be processed based on car movement

        Args:
            gps_data: Current GPS data
            frame_id: Current frame number

        Returns:
            True if frame should be processed, False if it should be skipped
        """
        # Always process first frame
        if len(self.gps_history) == 0:
            self._add_gps_data(gps_data)
            self.total_frames_processed += 1
            self.logger.debug(f"Frame {frame_id}: First frame - processing")
            return True

        # Check if car has moved significantly
        has_moved = self._has_moved_enough(gps_data)
        current_time = gps_data.timestamp

        if has_moved:
            # Car is moving
            self._handle_movement_detected(current_time, frame_id)
            self._add_gps_data(gps_data)
            self.total_frames_processed += 1
            return True
        else:
            # Car hasn't moved much - check if we should skip
            if self._should_skip_stationary_frame(current_time, frame_id):
                self.total_frames_skipped += 1
                return False
            else:
                # Still in grace period - keep processing
                self._add_gps_data(gps_data)
                self.total_frames_processed += 1
                return True

    def _has_moved_enough(self, current_gps: GPSData) -> bool:
        """Check if car has moved beyond the threshold"""
        if not self.gps_history:
            return True

        # Calculate distance from most recent position
        last_gps = self.gps_history[-1]
        distance = self._calculate_distance(last_gps, current_gps)

        moved_enough = distance >= self.config.movement_threshold_meters

        if moved_enough:
            self.logger.debug(f"Movement detected: {distance:.1f}m")

        return moved_enough

    def _should_skip_stationary_frame(self, current_time: float, frame_id: int) -> bool:
        """Determine if we should skip this frame due to stationary car"""
        if self.last_movement_time == 0:
            self.last_movement_time = current_time
            return False

        time_stationary = current_time - self.last_movement_time

        if time_stationary >= self.config.stationary_time_threshold:
            # Car has been stationary long enough - start skipping frames
            if not self.is_currently_stationary:
                self.logger.info(
                    f"Frame {frame_id}: Car stationary for {time_stationary:.1f}s - "
                    f"starting to skip frames for efficiency"
                )
                self.is_currently_stationary = True
                self.current_stationary_start = current_time

            return True  # Skip this frame

        return False  # Still in grace period

    def _handle_movement_detected(self, current_time: float, frame_id: int):
        """Handle when movement is detected after being stationary"""
        if self.is_currently_stationary:
            # End of stationary period
            if self.current_stationary_start:
                stationary_duration = current_time - self.current_stationary_start
                self.stationary_periods.append(stationary_duration)

                self.logger.info(
                    f"Frame {frame_id}: Movement resumed after "
                    f"{stationary_duration:.1f}s stationary period"
                )

            self.is_currently_stationary = False
            self.current_stationary_start = None

        # Update last movement time
        self.last_movement_time = current_time

    def _calculate_distance(self, gps1: GPSData, gps2: GPSData) -> float:
        """
        Calculate distance between two GPS points using Haversine formula

        Returns:
            Distance in meters
        """
        # Earth's radius in meters
        R = 6378137.0

        # Convert to radians
        lat1_rad = np.radians(gps1.latitude)
        lat2_rad = np.radians(gps2.latitude)
        dlat = np.radians(gps2.latitude - gps1.latitude)
        dlon = np.radians(gps2.longitude - gps1.longitude)

        # Haversine formula
        a = (
            np.sin(dlat / 2) ** 2
            + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin(dlon / 2) ** 2
        )
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))

        return R * c

    def _add_gps_data(self, gps_data: GPSData):
        """Add GPS data to history"""
        self.gps_history.append(gps_data)

        # Keep history manageable (last 50 points)
        if len(self.gps_history) > 50:
            self.gps_history = self.gps_history[-50:]

    def get_statistics(self) -> dict:
        """Get static car detection statistics"""
        total_frames = self.total_frames_processed + self.total_frames_skipped

        return {
            "total_frames": total_frames,
            "processed_frames": self.total_frames_processed,
            "skipped_frames": self.total_frames_skipped,
            "skip_ratio": (
                self.total_frames_skipped / total_frames if total_frames > 0 else 0
            ),
            "stationary_periods_count": len(self.stationary_periods),
            "total_stationary_time": sum(self.stationary_periods),
            "avg_stationary_duration": (
                np.mean(self.stationary_periods) if self.stationary_periods else 0
            ),
            "max_stationary_duration": (
                max(self.stationary_periods) if self.stationary_periods else 0
            ),
            "currently_stationary": self.is_currently_stationary,
            "efficiency_gain": (
                f"{self.total_frames_skipped / total_frames * 100:.1f}%"
                if total_frames > 0
                else "0%"
            ),
        }

    def reset(self):
        """Reset detector state"""
        self.gps_history.clear()
        self.last_movement_time = 0.0
        self.is_currently_stationary = False
        self.total_frames_processed = 0
        self.total_frames_skipped = 0
        self.stationary_periods.clear()
        self.current_stationary_start = None


def create_static_car_detector(
    movement_threshold_m: float = 2.0,
    stationary_time_s: float = 10.0,
    gps_frame_interval: int = 6,
) -> StaticCarDetector:
    """
    Create a static car detector with specified parameters

    Args:
        movement_threshold_m: Minimum movement in meters to consider as moving
        stationary_time_s: Time in seconds before starting to skip frames
        gps_frame_interval: Normal GPS frame processing interval

    Returns:
        Configured static car detector
    """
    config = StaticCarConfig(
        movement_threshold_meters=movement_threshold_m,
        stationary_time_threshold=stationary_time_s,
        gps_frame_interval=gps_frame_interval,
    )

    return StaticCarDetector(config)

================
File: argus_track/__version__.py
================
"""Version information for ByteTrack Light Post Tracking System"""

__version__ = "1.0.0"
__author__ = "Light Post Tracking Team"
__email__ = "joaquin.olivera@gmial.com"
__description__ = (
    "ByteTrack implementation optimized for light post tracking with GPS integration"
)

================
File: argus_track/requirements.txt
================
# argus_track/requirements.txt (UPDATED WITH GPS EXTRACTION)

# Core dependencies
numpy>=1.19.0
scipy>=1.5.0
opencv-python>=4.5.0
filterpy>=1.4.5
numba>=0.53.0  # For JIT compilation

# PyTorch for YOLOv11 support
torch>=1.9.0
torchvision>=0.10.0
torchaudio>=0.9.0

# YOLOv11 specific
ultralytics>=8.0.0  # For YOLOv11 support

# Optional optimizations
lap>=0.4.0  # Faster Hungarian algorithm

# Visualization
matplotlib>=3.3.0
seaborn>=0.11.0

# Development dependencies
pytest>=6.0.0
pytest-benchmark>=3.4.0
black>=21.0
flake8>=3.9.0
mypy>=0.910

# Documentation
sphinx>=4.0.0
sphinx-rtd-theme>=0.5.0

# GPS support
pyproj>=3.0.0  # For GPS coordinate transformations
scikit-learn>=0.24.0  # For clustering in static analysis
pynvml>=11.0.0  # Optional: For GPU monitoring

# GPS visualization
folium>=0.12.0  # For interactive maps
geojson>=2.5.0  # For GeoJSON export

# Stereo vision and 3D processing
transforms3d>=0.3.1  # For 3D transformations
open3d>=0.13.0  # Optional: For 3D visualization

# Configuration and data handling
pyyaml>=5.4.0  # For YAML configuration files
pandas>=1.3.0  # For data analysis and CSV handling

# Image processing enhancements
Pillow>=8.0.0  # Enhanced image processing
scikit-image>=0.18.0  # Additional image processing algorithms

# GPS EXTRACTION DEPENDENCIES
# ============================

# HTML/XML parsing for GPS metadata
beautifulsoup4>=4.9.0  # For parsing GPS metadata from ExifTool output
lxml>=4.6.0  # XML parser backend for BeautifulSoup

# GPS metadata handling
GPSPhoto>=2.2.0  # For reading/writing GPS metadata in images (optional)

# GoPro telemetry extraction (optional but recommended)
gopro-overlay>=0.10.0  # For GoPro telemetry data extraction

# ExifTool integration (ExifTool must be installed separately)
# Note: ExifTool (https://exiftool.org/) must be installed on the system
# Windows: Download from https://exiftool.org/
# macOS: brew install exiftool
# Linux: sudo apt-get install libimage-exiftool-perl

# Video processing enhancements
ffmpeg-python>=0.2.0  # For video metadata extraction (alternative method)

# Time and date handling
python-dateutil>=2.8.0  # Enhanced date parsing

# Process management
psutil>=5.8.0  # For system monitoring during processing

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
repomix-output.txt
repomix-output.xml

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Bell South

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: argus_track/core/track.py
================
"""Track data structure"""

from dataclasses import dataclass, field
from typing import List, Optional

import numpy as np

from .detection import Detection


@dataclass
class Track:
    """Represents a tracked object through multiple frames"""

    track_id: int
    detections: List[Detection] = field(default_factory=list)
    kalman_filter: Optional["KalmanBoxTracker"] = None
    state: str = "tentative"  # tentative, confirmed, lost, removed
    hits: int = 0  # Number of successful updates
    age: int = 0  # Total frames since creation
    time_since_update: int = 0  # Frames since last update
    start_frame: int = 0

    @property
    def is_confirmed(self) -> bool:
        """Check if track is confirmed (has enough hits)"""
        return self.state == "confirmed"

    @property
    def is_active(self) -> bool:
        """Check if track is currently active"""
        return self.state in ["tentative", "confirmed"]

    def to_tlbr(self) -> np.ndarray:
        """Get current position in tlbr format"""
        if self.kalman_filter is None:
            return self.detections[-1].tlbr if self.detections else np.zeros(4)
        return self.kalman_filter.get_state()

    @property
    def last_detection(self) -> Optional[Detection]:
        """Get the most recent detection"""
        return self.detections[-1] if self.detections else None

    @property
    def trajectory(self) -> List[np.ndarray]:
        """Get trajectory as list of center points"""
        return [det.center for det in self.detections]

    def to_dict(self) -> dict:
        """Convert to dictionary representation"""
        return {
            "track_id": self.track_id,
            "state": self.state,
            "hits": self.hits,
            "age": self.age,
            "time_since_update": self.time_since_update,
            "start_frame": self.start_frame,
            "detections": [
                det.to_dict() for det in self.detections[-10:]
            ],  # Last 10 detections
        }

================
File: argus_track/trackers/unique_tracker.py
================
# argus_track/trackers/unified_lightpost_tracker.py

"""
Unified Light Post Tracker - Clean, GPS-informed tracking
=========================================================

Combines best features from both trackers with GPS movement context
to solve track fragmentation and resurrection issues.
"""

import logging
import time
from typing import Any, Dict, List, Optional, Tuple

import cv2
import numpy as np
from ultralytics import YOLO

from ..config import TrackerConfig
from ..core import Detection, GPSData
from ..utils.gps_sync_tracker import GPSSynchronizer
from ..utils.output_manager import OutputManager
from ..utils.overlap_fixer import OverlapFixer
from ..utils.smart_track_manager import CleanTrackManager
from ..utils.static_car_detector import StaticCarConfig, StaticCarDetector
from ..utils.visualization import RealTimeVisualizer


class UnifiedLightPostTracker:
    """
    Unified Light Post Tracker with GPS movement context

    Clean, focused tracker that uses GPS to:
    - Detect vehicle movement (skip stationary frames)
    - Prevent impossible track resurrections (forward motion logic)
    - Provide movement context for ID management

    Solves:
    - Track fragmentation
    - Track ID resurrection
    - Duplicate ID assignment
    """

    def __init__(
        self,
        config: TrackerConfig,
        model_path: str,
        show_realtime: bool = False,
        display_size: Tuple[int, int] = (1280, 720),
    ):
        """
        Initialize unified tracker

        Args:
            config: Tracker configuration
            model_path: Path to YOLOv11 model
            show_realtime: Show real-time visualization
            display_size: Display window size
        """
        self.config = config
        self.model_path = model_path
        self.show_realtime = show_realtime
        self.display_size = display_size

        # Initialize logger
        self.logger = logging.getLogger(f"{__name__}.UnifiedLightPostTracker")

        # Initialize YOLO model
        self.model = YOLO(model_path)
        self.class_names = list(self.model.names.values())
        self.logger.info(f"Model classes: {self.class_names}")

        # Initialize core components
        self.track_manager = CleanTrackManager(config)
        self.overlap_fixer = OverlapFixer(overlap_threshold=0.3, distance_threshold=1.0)

        # GPS and movement tracking
        self.gps_synchronizer: Optional[GPSSynchronizer] = None
        self.static_car_detector: Optional[StaticCarDetector] = None
        self.current_gps: Optional[GPSData] = None
        self.previous_gps: Optional[GPSData] = None
        self.vehicle_speed: float = 0.0
        self.vehicle_moved_distance: float = 0.0

        # Initialize static car detection
        if config.enable_static_car_detection:
            static_config = StaticCarConfig(
                movement_threshold_meters=config.static_movement_threshold_m,
                stationary_time_threshold=config.static_time_threshold_s,
                gps_frame_interval=config.gps_frame_interval,
            )
            self.static_car_detector = StaticCarDetector(static_config)
            self.logger.info("Static car detection enabled")

        # Initialize real-time visualizer
        self.visualizer = None
        if show_realtime:
            self.visualizer = RealTimeVisualizer(
                window_name="Unified Light Post Tracking",
                display_size=display_size,
                show_info_panel=True,
            )
            self.logger.info("Real-time visualization enabled")

        # Processing statistics
        self.processing_times = []
        self.frame_count = 0
        self.processed_frame_count = 0

        self.logger.info("Unified Light Post Tracker initialized")

    def process_video(
        self,
        video_path: str,
        gps_data: Optional[List[GPSData]] = None,
        output_path: Optional[str] = None,
        save_results: bool = True,
    ) -> Dict[str, Any]:
        """
        Process video with unified tracking

        Args:
            video_path: Path to input video
            gps_data: Optional GPS data
            output_path: Optional output video path
            save_results: Whether to save results

        Returns:
            Processing results dictionary
        """
        self.logger.info(f"Starting unified tracking: {video_path}")

        # Open video
        cap = cv2.VideoCapture(video_path)
        if not cap.isOpened():
            raise IOError(f"Could not open video: {video_path}")

        # Get video properties
        fps = cap.get(cv2.CAP_PROP_FPS)
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

        self.logger.info(
            f"Video: {total_frames} frames, {fps:.1f} FPS, {width}x{height}"
        )

        # Initialize GPS synchronizer
        if gps_data:
            self.gps_synchronizer = GPSSynchronizer(gps_data, fps, gps_fps=10.0)
            sync_stats = self.gps_synchronizer.get_processing_statistics()
            self.logger.info(f"GPS sync: {sync_stats['sync_frames']} frames to process")
        else:
            self.logger.warning("No GPS data - processing all frames")

        # Initialize output manager
        output_manager = OutputManager(video_path, self.class_names)

        # Setup video writer
        out_writer = None
        if output_path and self.show_realtime:
            fourcc = cv2.VideoWriter_fourcc(*"mp4v")
            output_fps = (
                fps / self.config.gps_frame_interval if self.gps_synchronizer else fps
            )
            out_writer = cv2.VideoWriter(
                output_path, fourcc, output_fps, (width, height)
            )

        # Processing loop
        current_frame_idx = 0
        processed_frames = 0
        skipped_frames_gps = 0
        skipped_frames_static = 0

        try:
            while True:
                ret, frame = cap.read()
                if not ret:
                    break

                start_time = time.time()

                # Check GPS synchronization
                should_process_gps = True
                current_gps = None

                if self.gps_synchronizer:
                    should_process_gps = self.gps_synchronizer.should_process_frame(
                        current_frame_idx
                    )
                    if should_process_gps:
                        current_gps = self.gps_synchronizer.get_gps_for_frame(
                            current_frame_idx
                        )
                    else:
                        skipped_frames_gps += 1

                # Check static car detection
                should_process_static = True
                if should_process_gps and self.static_car_detector and current_gps:
                    should_process_static = (
                        self.static_car_detector.should_process_frame(
                            current_gps, current_frame_idx
                        )
                    )
                    if not should_process_static:
                        skipped_frames_static += 1

                # Final decision: process frame?
                should_process = should_process_gps and should_process_static

                if not should_process:
                    current_frame_idx += 1
                    continue

                # Update GPS movement context
                self._update_gps_context(current_gps)

                # Process frame
                frame_timestamp = current_frame_idx / fps
                detections = self._process_frame(
                    frame, current_frame_idx, frame_timestamp
                )

                # Add to output manager
                output_manager.add_frame_data(
                    frame_id=current_frame_idx,
                    timestamp=frame_timestamp,
                    detections=detections,
                    gps_data=current_gps,
                )

                # Real-time visualization
                if self.show_realtime and self.visualizer:
                    should_continue = self._visualize_frame(
                        frame,
                        detections,
                        current_frame_idx,
                        current_gps,
                        total_frames,
                        processed_frames,
                    )

                    if not should_continue:
                        self.logger.info("User requested quit")
                        break

                # Save frame to output video
                if out_writer and self.show_realtime:
                    vis_frame = self._create_visualization_frame(
                        frame, detections, current_gps
                    )
                    out_writer.write(vis_frame)

                # Performance tracking
                process_time = time.time() - start_time
                self.processing_times.append(process_time)
                processed_frames += 1

                # Progress logging
                if processed_frames % 30 == 0:
                    avg_time = np.mean(self.processing_times[-30:])
                    progress = current_frame_idx / total_frames * 100

                    self.logger.info(
                        f"Progress: {progress:.1f}% | "
                        f"Processed: {processed_frames} | "
                        f"Skipped (GPS): {skipped_frames_gps} | "
                        f"Skipped (Static): {skipped_frames_static} | "
                        f"Avg time: {avg_time*1000:.1f}ms | "
                        f"Speed: {self.vehicle_speed:.1f}m/s"
                    )

                current_frame_idx += 1

        except KeyboardInterrupt:
            self.logger.info("Processing interrupted by user")
        except Exception as e:
            self.logger.error(f"Error during processing: {e}")
            raise
        finally:
            # Cleanup
            cap.release()
            if out_writer:
                out_writer.release()
            if self.visualizer:
                self.visualizer.close()
            cv2.destroyAllWindows()

        # Processing summary
        total_time = sum(self.processing_times)
        avg_fps = processed_frames / total_time if total_time > 0 else 0

        results = {
            "total_frames": total_frames,
            "processed_frames": processed_frames,
            "skipped_frames_gps": skipped_frames_gps,
            "skipped_frames_static": skipped_frames_static,
            "processing_time": total_time,
            "avg_fps": avg_fps,
            "track_manager_stats": self.track_manager.get_statistics(),
            "output_summary": output_manager.get_processing_summary(),
        }

        self.logger.info("=== PROCESSING COMPLETE ===")
        self.logger.info(f"Total frames: {total_frames}")
        self.logger.info(f"Processed frames: {processed_frames}")
        self.logger.info(f"Processing time: {total_time:.1f}s")
        self.logger.info(f"Average FPS: {avg_fps:.1f}")

        # Track manager statistics
        track_stats = self.track_manager.get_statistics()
        self.logger.info(f"Active tracks: {track_stats['active_tracks']}")
        self.logger.info(f"Total tracks created: {track_stats['total_tracks_created']}")

        # Save results
        if save_results:
            json_path, csv_path = output_manager.export_both()
            results["json_output"] = json_path
            results["csv_output"] = csv_path

            # Print summary
            output_manager.print_summary()

        return results

    def _update_gps_context(self, current_gps: Optional[GPSData]):
        """Update GPS movement context for tracking decisions"""
        if current_gps is None:
            return

        # Calculate vehicle movement
        if self.previous_gps is not None:
            # Calculate distance moved
            distance = self._calculate_gps_distance(
                self.previous_gps.latitude,
                self.previous_gps.longitude,
                current_gps.latitude,
                current_gps.longitude,
            )

            # Calculate time difference
            dt = current_gps.timestamp - self.previous_gps.timestamp
            if dt > 0:
                self.vehicle_speed = distance / dt
                self.vehicle_moved_distance += distance

            # Pass movement context to track manager
            self.track_manager.update_movement_context(
                vehicle_speed=self.vehicle_speed,
                distance_moved=distance,
                total_distance=self.vehicle_moved_distance,
            )

        # Update GPS references
        self.current_gps = current_gps
        self.previous_gps = current_gps

    def _calculate_gps_distance(
        self, lat1: float, lon1: float, lat2: float, lon2: float
    ) -> float:
        """Calculate distance between GPS points in meters"""
        R = 6378137.0  # Earth radius
        lat1_rad = np.radians(lat1)
        lat2_rad = np.radians(lat2)
        dlat = np.radians(lat2 - lat1)
        dlon = np.radians(lon2 - lon1)

        a = (
            np.sin(dlat / 2) ** 2
            + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin(dlon / 2) ** 2
        )
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))

        return R * c

    def _process_frame(
        self, frame: np.ndarray, frame_id: int, timestamp: float
    ) -> List[Detection]:
        """Process single frame with GPS-informed tracking"""

        # NEW: Update GPS context for motion prediction
        if hasattr(self.track_manager, "update_gps_context"):
            self.track_manager.update_gps_context(self.current_gps, self.previous_gps)

        # Run YOLO tracking (existing code)
        track_params = self.config.get_ultralytics_track_params()
        results = self.model.track(frame, **track_params)

        # Apply overlap fixer (existing code)
        fixed_detections = self.overlap_fixer.fix_ultralytics_results(
            results[0], self.current_gps, frame_id
        )

        # Convert to Detection objects (existing code)
        raw_detections = self._convert_fixed_detections(fixed_detections, frame_id)

        # Apply GPS-informed track management (existing code)
        processed_detections = self.track_manager.process_frame_detections(
            raw_detections, frame_id, timestamp
        )

        return processed_detections

    def _convert_fixed_detections(
        self, fixed_detections: List[Dict], frame_id: int
    ) -> List[Detection]:
        """Convert fixed detections to Detection objects"""
        detections = []

        for det_dict in fixed_detections:
            detection = Detection(
                bbox=np.array(det_dict["bbox"]),
                score=float(det_dict["score"]),
                class_id=int(det_dict["class_id"]),
                frame_id=frame_id,
            )
            detection.track_id = int(det_dict["track_id"])
            detections.append(detection)

        return detections

    def _visualize_frame(
        self,
        frame: np.ndarray,
        detections: List[Detection],
        frame_id: int,
        gps_data: Optional[GPSData],
        total_frames: int,
        processed_frames: int,
    ) -> bool:
        """Visualize frame with real-time display"""

        # Prepare frame info
        frame_info = {
            "frame_idx": frame_id,
            "total_frames": total_frames,
            "processed_frames": processed_frames,
            "gps_available": gps_data is not None,
            "vehicle_speed": self.vehicle_speed,
            "distance_moved": self.vehicle_moved_distance,
        }

        # Prepare GPS info
        gps_info = None
        if gps_data:
            gps_info = {
                "latitude": gps_data.latitude,
                "longitude": gps_data.longitude,
                "heading": gps_data.heading,
                "accuracy": gps_data.accuracy,
                "vehicle_speed_ms": self.vehicle_speed,
                "vehicle_speed_kmh": self.vehicle_speed * 3.6,
            }

        # Convert detections to tracks for visualization
        tracks = []
        for detection in detections:

            class MockTrack:
                def __init__(self, detection):
                    self.track_id = detection.track_id
                    self.state = "confirmed"
                    self.detections = [detection]
                    self.hits = 1
                    self.age = 1
                    self.time_since_update = 0
                    self._bbox = detection.bbox

                def to_tlbr(self):
                    return self._bbox

            track = MockTrack(detection)
            tracks.append(track)

        # Visualize
        return self.visualizer.visualize_frame(
            frame, detections, tracks, gps_info, frame_info
        )

    def _create_visualization_frame(
        self,
        frame: np.ndarray,
        detections: List[Detection],
        gps_data: Optional[GPSData],
    ) -> np.ndarray:
        """Create visualization frame for video output"""

        vis_frame = frame.copy()

        # Draw detections
        for detection in detections:
            bbox = detection.bbox.astype(int)
            class_name = (
                self.class_names[detection.class_id]
                if detection.class_id < len(self.class_names)
                else f"class_{detection.class_id}"
            )

            # Draw bounding box
            cv2.rectangle(
                vis_frame, (bbox[0], bbox[1]), (bbox[2], bbox[3]), (0, 255, 0), 2
            )

            # Draw label
            label = f"ID:{detection.track_id} {class_name} {detection.score:.2f}"
            label_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)[0]

            # Background for text
            cv2.rectangle(
                vis_frame,
                (bbox[0], bbox[1] - label_size[1] - 10),
                (bbox[0] + label_size[0], bbox[1]),
                (0, 255, 0),
                -1,
            )

            # Text
            cv2.putText(
                vis_frame,
                label,
                (bbox[0], bbox[1] - 5),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.5,
                (0, 0, 0),
                2,
            )

        # Add GPS and movement info overlay
        if gps_data:
            info_lines = [
                f"GPS: {gps_data.latitude:.6f}, {gps_data.longitude:.6f}",
                f"Speed: {self.vehicle_speed * 3.6:.1f} km/h",
                f"Distance: {self.vehicle_moved_distance:.1f} m",
            ]

            y_offset = 30
            for line in info_lines:
                cv2.putText(
                    vis_frame,
                    line,
                    (10, y_offset),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.7,
                    (255, 255, 0),
                    2,
                )
                y_offset += 30

        # Add detection count
        det_text = f"Detections: {len(detections)}"
        cv2.putText(
            vis_frame,
            det_text,
            (10, vis_frame.shape[0] - 60),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.7,
            (255, 255, 0),
            2,
        )

        # Add track statistics
        track_stats = self.track_manager.get_statistics()
        stats_text = f"Active Tracks: {track_stats['active_tracks']}"
        cv2.putText(
            vis_frame,
            stats_text,
            (10, vis_frame.shape[0] - 30),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.7,
            (255, 255, 0),
            2,
        )

        return vis_frame

    def get_statistics(self) -> Dict[str, Any]:
        """Get comprehensive tracking statistics"""
        track_stats = self.track_manager.get_statistics()

        return {
            "processed_frames": self.processed_frame_count,
            "avg_processing_time": (
                np.mean(self.processing_times) if self.processing_times else 0
            ),
            "vehicle_speed": self.vehicle_speed,
            "distance_moved": self.vehicle_moved_distance,
            "track_manager": track_stats,
            "model_classes": self.class_names,
        }

================
File: argus_track/utils/gps_extraction.py
================
# argus_track/utils/gps_extraction.py (NEW FILE)

"""
GPS Data Extraction from GoPro Videos
=====================================
Integrated GPS extraction functionality for Argus Track stereo processing.
Supports both ExifTool and GoPro API methods for extracting GPS metadata.
"""

import logging
import os
import shutil
import subprocess
import tempfile
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional, Tuple

import numpy as np
from bs4 import BeautifulSoup

from ..core import GPSData

# Configure logging
logger = logging.getLogger(__name__)

# Try to import GoPro API if available
try:
    from gopro_overlay.goprotelemetry import telemetry

    GOPRO_API_AVAILABLE = True
except ImportError:
    GOPRO_API_AVAILABLE = False
    logger.debug("GoPro telemetry API not available")


# Check for ExifTool availability
def check_exiftool_available() -> bool:
    """Check if ExifTool is available in the system"""
    try:
        result = subprocess.run(
            ["exiftool", "-ver"], capture_output=True, text=True, timeout=10
        )
        return result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


EXIFTOOL_AVAILABLE = check_exiftool_available()


@dataclass
class GPSExtractionResult:
    """Result of GPS extraction operation"""

    success: bool
    gps_data: List[GPSData]
    method_used: str
    total_points: int
    time_range: Optional[Tuple[float, float]] = None
    error_message: Optional[str] = None


class GoProGPSExtractor:
    """Extract GPS data from GoPro videos using multiple methods"""

    def __init__(self, fps_video: float = 60.0, fps_gps: float = 10.0):
        """
        Initialize GPS extractor

        Args:
            fps_video: Video frame rate (default: 60 fps)
            fps_gps: GPS data rate (default: 10 Hz)
        """
        self.fps_video = fps_video
        self.fps_gps = fps_gps
        self.frame_time_ms = 1000.0 / fps_video

        # Check available extraction methods
        self.methods_available = []
        if EXIFTOOL_AVAILABLE:
            self.methods_available.append("exiftool")
            logger.debug("ExifTool method available")
        if GOPRO_API_AVAILABLE:
            self.methods_available.append("gopro_api")
            logger.debug("GoPro API method available")

        if not self.methods_available:
            logger.warning("No GPS extraction methods available!")

    def extract_gps_data(
        self, video_path: str, method: str = "auto"
    ) -> GPSExtractionResult:
        """
        Extract GPS data from GoPro video

        Args:
            video_path: Path to GoPro video file
            method: Extraction method ('auto', 'exiftool', 'gopro_api')

        Returns:
            GPSExtractionResult: Extraction results
        """
        if not os.path.exists(video_path):
            return GPSExtractionResult(
                success=False,
                gps_data=[],
                method_used="none",
                total_points=0,
                error_message=f"Video file not found: {video_path}",
            )

        # Determine extraction method
        if method == "auto":
            # Prefer GoPro API for better accuracy, fallback to ExifTool
            if "gopro_api" in self.methods_available:
                method = "gopro_api"
            elif "exiftool" in self.methods_available:
                method = "exiftool"
            else:
                return GPSExtractionResult(
                    success=False,
                    gps_data=[],
                    method_used="none",
                    total_points=0,
                    error_message="No GPS extraction methods available",
                )

        logger.info(f"Extracting GPS data from {video_path} using {method} method")

        try:
            if method == "exiftool":
                return self._extract_with_exiftool(video_path)
            elif method == "gopro_api":
                return self._extract_with_gopro_api(video_path)
            else:
                return GPSExtractionResult(
                    success=False,
                    gps_data=[],
                    method_used=method,
                    total_points=0,
                    error_message=f"Unknown extraction method: {method}",
                )
        except Exception as e:
            logger.error(f"Error extracting GPS data: {e}")
            return GPSExtractionResult(
                success=False,
                gps_data=[],
                method_used=method,
                total_points=0,
                error_message=str(e),
            )

    def _extract_with_exiftool(self, video_path: str) -> GPSExtractionResult:
        """Extract GPS data using ExifTool method"""
        temp_dir = tempfile.mkdtemp()

        try:
            metadata_file = os.path.join(temp_dir, "metadata.xml")
            gps_file = os.path.join(temp_dir, "gps_data.txt")

            # Extract metadata using ExifTool
            cmd = [
                "exiftool",
                "-api",
                "largefilesupport=1",
                "-ee",  # Extract embedded data
                "-G3",  # Show group names
                "-X",  # XML format
                video_path,
            ]

            logger.debug(f"Running ExifTool command: {' '.join(cmd)}")

            with open(metadata_file, "w") as f:
                result = subprocess.run(
                    cmd, stdout=f, stderr=subprocess.PIPE, text=True, timeout=300
                )

            if result.returncode != 0:
                raise RuntimeError(f"ExifTool failed: {result.stderr}")

            # Extract Track4 GPS data
            self._extract_track4_data(metadata_file, gps_file)

            # Parse GPS data
            gps_data = self._parse_gps_file(gps_file)

            if gps_data:
                time_range = (gps_data[0].timestamp, gps_data[-1].timestamp)
                return GPSExtractionResult(
                    success=True,
                    gps_data=gps_data,
                    method_used="exiftool",
                    total_points=len(gps_data),
                    time_range=time_range,
                )
            else:
                return GPSExtractionResult(
                    success=False,
                    gps_data=[],
                    method_used="exiftool",
                    total_points=0,
                    error_message="No GPS data found in metadata",
                )

        finally:
            # Cleanup temporary files
            shutil.rmtree(temp_dir, ignore_errors=True)

    def _extract_with_gopro_api(self, video_path: str) -> GPSExtractionResult:
        """Extract GPS data using GoPro API method"""
        try:
            # Extract telemetry data
            telem = telemetry.Telemetry(video_path)

            if not telem.has_gps():
                return GPSExtractionResult(
                    success=False,
                    gps_data=[],
                    method_used="gopro_api",
                    total_points=0,
                    error_message="No GPS data found in video",
                )

            # Get GPS track
            gps_track = telem.gps_track()
            gps_data = []

            for point in gps_track:
                if point.lat != 0.0 and point.lon != 0.0:
                    # Convert timestamp to seconds
                    timestamp = (
                        point.timestamp.total_seconds()
                        if hasattr(point.timestamp, "total_seconds")
                        else point.timestamp
                    )

                    gps_point = GPSData(
                        timestamp=float(timestamp),
                        latitude=float(point.lat),
                        longitude=float(point.lon),
                        altitude=float(getattr(point, "alt", 0.0)),
                        heading=float(getattr(point, "heading", 0.0)),
                        accuracy=float(getattr(point, "dop", 1.0)),
                    )
                    gps_data.append(gps_point)

            if gps_data:
                time_range = (gps_data[0].timestamp, gps_data[-1].timestamp)
                return GPSExtractionResult(
                    success=True,
                    gps_data=gps_data,
                    method_used="gopro_api",
                    total_points=len(gps_data),
                    time_range=time_range,
                )
            else:
                return GPSExtractionResult(
                    success=False,
                    gps_data=[],
                    method_used="gopro_api",
                    total_points=0,
                    error_message="No valid GPS points found",
                )

        except Exception as e:
            raise RuntimeError(f"GoPro API extraction failed: {e}")

    def _extract_track4_data(self, metadata_file: str, output_file: str) -> None:
        """Extract Track4 GPS data from metadata XML file"""
        try:
            with open(metadata_file, "r", encoding="utf-8") as in_file, open(
                output_file, "w", encoding="utf-8"
            ) as out_file:

                for line in in_file:
                    # Look for Track4 GPS data
                    if "Track4" in line or "GPS" in line:
                        out_file.write(line)

            logger.debug(f"Extracted Track4 data to {output_file}")

        except Exception as e:
            logger.error(f"Error extracting Track4 data: {e}")
            raise

    def _parse_gps_file(self, gps_file: str) -> List[GPSData]:
        """Parse GPS data from extracted Track4 file"""
        gps_data = []

        try:
            with open(gps_file, "r", encoding="utf-8") as f:
                content = f.read()

            # Skip first two lines if they exist
            lines = (
                content.split("\n")[2:]
                if len(content.split("\n")) > 2
                else content.split("\n")
            )

            current_timestamp = None
            current_lat = None
            current_lon = None

            for line in lines:
                if not line.strip():
                    continue

                # Parse XML-like content
                soup = BeautifulSoup(line, "html.parser")
                text_content = soup.get_text()

                # Look for GPS tags
                if ":GPSLatitude>" in line:
                    current_lat = self._convert_gps_coordinate(text_content)
                elif ":GPSLongitude>" in line and current_lat is not None:
                    current_lon = self._convert_gps_coordinate(text_content)
                elif ":GPSDateTime>" in line:
                    current_timestamp = self._convert_timestamp(text_content)

                    # If we have complete GPS data, save it
                    if (
                        current_timestamp is not None
                        and current_lat is not None
                        and current_lon is not None
                        and current_lat != 0.0
                        and current_lon != 0.0
                    ):

                        gps_point = GPSData(
                            timestamp=current_timestamp,
                            latitude=current_lat,
                            longitude=current_lon,
                            altitude=0.0,
                            heading=0.0,
                            accuracy=1.0,
                        )
                        gps_data.append(gps_point)

                        # Reset for next point
                        current_lat = None
                        current_lon = None

            logger.info(f"Parsed {len(gps_data)} GPS points from file")
            return gps_data

        except Exception as e:
            logger.error(f"Error parsing GPS file: {e}")
            return []

    def _convert_gps_coordinate(self, coord_str: str) -> float:
        """Convert GPS coordinate from DMS format to decimal degrees"""
        if not coord_str or not isinstance(coord_str, str):
            return 0.0

        try:
            # Clean the string
            coord_str = coord_str.strip()

            # Handle the format: "34 deg 39' 45.72" S"
            import re

            # Pattern for: "34 deg 39' 45.72" S"
            pattern = r"(\d+)\s+deg\s+(\d+)'\s+([\d.]+)\"\s*([NSEW])"
            match = re.search(pattern, coord_str)

            if match:
                degrees = float(match.group(1))
                minutes = float(match.group(2))
                seconds = float(match.group(3))
                direction = match.group(4)

                # Convert to decimal degrees
                decimal = degrees + minutes / 60.0 + seconds / 3600.0

                # Apply sign based on direction
                if direction in ["S", "W"]:
                    decimal = -decimal

                return decimal

            if coord_str.startswith("<"):
                coord_str = coord_str[1:]
            if coord_str.endswith(">"):
                coord_str = coord_str[:-1]

            # Parse DMS format: "deg min' sec" N/S/E/W"
            parts = coord_str.split(" ")
            if len(parts) < 6:
                logger.warning(f"Invalid GPS coordinate format: {coord_str}")
                return 0.0

            degrees = float(parts[1])
            minutes = float(parts[3].replace("'", ""))
            seconds = float(parts[4].replace('"', ""))
            direction = parts[5][0] if len(parts[5]) > 0 else "N"

            # Convert to decimal degrees
            decimal = degrees + minutes / 60.0 + seconds / 3600.0

            # Apply sign based on direction
            if direction in ["S", "W"]:
                decimal = -decimal

            return decimal

        except (ValueError, IndexError) as e:
            logger.warning(f"Error converting GPS coordinate '{coord_str}': {e}")
            return 0.0

    def _convert_timestamp(self, timestamp_str: str) -> float:
        """Convert timestamp string to Unix timestamp"""
        if not timestamp_str:
            return 0.0

        try:
            # Clean timestamp string
            timestamp_str = timestamp_str.strip()
            if timestamp_str.startswith("<"):
                timestamp_str = timestamp_str[1:]
            if timestamp_str.endswith(">"):
                timestamp_str = timestamp_str[:-1]

            # Parse timestamp formats
            try:
                # Try with microseconds
                dt = datetime.strptime(timestamp_str, "%Y:%m:%d %H:%M:%S.%f")
            except ValueError:
                # Try without microseconds
                dt = datetime.strptime(timestamp_str, "%Y:%m:%d %H:%M:%S")

            return dt.timestamp()

        except ValueError as e:
            logger.warning(f"Error converting timestamp '{timestamp_str}': {e}")
            return 0.0

    def synchronize_with_video(
        self, gps_data: List[GPSData], video_duration: float, target_fps: float = 10.0
    ) -> List[GPSData]:
        """
        Synchronize GPS data with video timeline

        Args:
            gps_data: Raw GPS data
            video_duration: Video duration in seconds
            target_fps: Target GPS sampling rate

        Returns:
            List[GPSData]: Synchronized GPS data
        """
        if not gps_data:
            return []

        # Sort GPS data by timestamp
        sorted_gps = sorted(gps_data, key=lambda x: x.timestamp)

        # Normalize timestamps to start from 0
        start_time = sorted_gps[0].timestamp
        for gps_point in sorted_gps:
            gps_point.timestamp -= start_time

        # Create synchronized timeline
        sync_interval = 1.0 / target_fps
        sync_timeline = np.arange(0, video_duration, sync_interval)

        # Interpolate GPS data to match timeline
        timestamps = np.array([gps.timestamp for gps in sorted_gps])
        latitudes = np.array([gps.latitude for gps in sorted_gps])
        longitudes = np.array([gps.longitude for gps in sorted_gps])

        # Interpolate
        sync_gps = []
        for sync_time in sync_timeline:
            if sync_time <= timestamps[-1]:
                # Find closest GPS points for interpolation
                idx = np.searchsorted(timestamps, sync_time)

                if idx == 0:
                    # Use first point
                    lat = latitudes[0]
                    lon = longitudes[0]
                elif idx >= len(timestamps):
                    # Use last point
                    lat = latitudes[-1]
                    lon = longitudes[-1]
                else:
                    # Linear interpolation
                    t1, t2 = timestamps[idx - 1], timestamps[idx]
                    lat1, lat2 = latitudes[idx - 1], latitudes[idx]
                    lon1, lon2 = longitudes[idx - 1], longitudes[idx]

                    alpha = (sync_time - t1) / (t2 - t1)
                    lat = lat1 + alpha * (lat2 - lat1)
                    lon = lon1 + alpha * (lon2 - lon1)

                sync_point = GPSData(
                    timestamp=sync_time,
                    latitude=lat,
                    longitude=lon,
                    altitude=0.0,
                    heading=0.0,
                    accuracy=1.0,
                )
                sync_gps.append(sync_point)

        logger.info(
            f"Synchronized {len(sync_gps)} GPS points for {video_duration:.1f}s video"
        )
        return sync_gps


def extract_gps_from_stereo_videos(
    left_video: str, right_video: str, method: str = "auto"
) -> Tuple[List[GPSData], str]:
    """
    Extract GPS data from stereo video pair

    Args:
        left_video: Path to left camera video
        right_video: Path to right camera video
        method: Extraction method ('auto', 'exiftool', 'gopro_api')

    Returns:
        Tuple[List[GPSData], str]: GPS data and method used
    """
    extractor = GoProGPSExtractor()

    # Try extracting from left video first
    logger.info("Attempting GPS extraction from left video")
    result_left = extractor.extract_gps_data(left_video, method)

    if result_left.success and result_left.total_points > 0:
        logger.info(
            f"Successfully extracted {result_left.total_points} GPS points from left video"
        )
        return result_left.gps_data, result_left.method_used

    # Fallback to right video
    logger.info("Left video GPS extraction failed, trying right video")
    result_right = extractor.extract_gps_data(right_video, method)

    if result_right.success and result_right.total_points > 0:
        logger.info(
            f"Successfully extracted {result_right.total_points} GPS points from right video"
        )
        return result_right.gps_data, result_right.method_used

    # No GPS data found
    logger.warning("No GPS data found in either video")
    return [], "none"


def save_gps_to_csv(gps_data: List[GPSData], output_path: str) -> None:
    """
    Save GPS data to CSV file for Argus Track

    Args:
        gps_data: GPS data to save
        output_path: Path to output CSV file
    """
    import csv

    with open(output_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(
            ["timestamp", "latitude", "longitude", "altitude", "heading", "accuracy"]
        )

        for gps in gps_data:
            writer.writerow(
                [
                    gps.timestamp,
                    gps.latitude,
                    gps.longitude,
                    gps.altitude,
                    gps.heading,
                    gps.accuracy,
                ]
            )

    logger.info(f"Saved {len(gps_data)} GPS points to {output_path}")

================
File: argus_track/utils/overlap_fixer.py
================
# Create new file: argus_track/utils/overlap_fixer.py

"""
Simple Overlap Fixer for Ultralytics Tracking Issues
"""

import logging
from typing import Dict, List, Optional, Tuple

import numpy as np


class OverlapFixer:
    """
    Fixes Ultralytics tracking issues:
    1. Removes overlapping bounding boxes in same frame
    2. Consolidates track IDs based on GPS proximity
    """

    def __init__(self, overlap_threshold: float = 0.5, distance_threshold: float = 3.0):
        """
        Initialize overlap fixer

        Args:
            overlap_threshold: IoU threshold for detecting overlaps (0.5 = 50% overlap)
            distance_threshold: GPS distance threshold for same object (meters)
        """
        self.overlap_threshold = overlap_threshold
        self.distance_threshold = distance_threshold
        self.logger = logging.getLogger(f"{__name__}.OverlapFixer")

        self.persistent_id_mapping: Dict[int, int] = {}  # ultralytics_id -> stable_id
        self.stable_id_counter = 1
        self.id_position_history: Dict[int, List[np.ndarray]] = (
            {}
        )  # stable_id -> recent_positions

        # Track ID consolidation
        self.id_mapping = {}  # original_id -> consolidated_id
        self.next_consolidated_id = 1
        self.track_positions = {}  # track_id -> recent GPS positions
        self.fixed_count = 0
        self.overlap_count = 0

    def fix_ultralytics_results(
        self, ultralytics_result, current_gps: Optional["GPSData"], frame_id: int
    ) -> List[Dict]:
        """
        Fix Ultralytics tracking results

        Args:
            ultralytics_result: Single result from model.track()[0]
            current_gps: Current GPS data
            frame_id: Current frame number

        Returns:
            List of fixed detection dictionaries
        """
        # Extract raw detections
        raw_detections = self._extract_detections(ultralytics_result, frame_id)

        if not raw_detections:
            return []

        # Step 1: Remove overlapping bounding boxes
        non_overlapping = self._remove_overlapping_boxes(raw_detections, frame_id)

        # Step 2: Consolidate track IDs
        consolidated = self._consolidate_track_ids(non_overlapping, current_gps)

        return consolidated

    def _extract_detections(self, result, frame_id: int) -> List[Dict]:
        """Extract detections from Ultralytics result"""
        detections = []

        if (
            not result.boxes
            or not hasattr(result.boxes, "id")
            or result.boxes.id is None
        ):
            return detections

        boxes = result.boxes.xyxy.cpu().numpy()
        scores = result.boxes.conf.cpu().numpy()
        classes = result.boxes.cls.cpu().numpy().astype(int)
        track_ids = result.boxes.id.cpu().numpy().astype(int)

        for box, score, cls_id, track_id in zip(boxes, scores, classes, track_ids):
            detections.append(
                {
                    "bbox": box,
                    "score": float(score),
                    "class_id": int(cls_id),
                    "track_id": int(track_id),
                    "frame": frame_id,
                }
            )

        return detections

    def _remove_overlapping_boxes(
        self, detections: List[Dict], frame_id: int
    ) -> List[Dict]:
        """Remove overlapping bounding boxes in same frame"""
        if len(detections) <= 1:
            return detections

        # Calculate IoU for all pairs
        keep_indices = set(range(len(detections)))
        overlaps_removed = 0

        for i in range(len(detections)):
            if i not in keep_indices:
                continue

            for j in range(i + 1, len(detections)):
                if j not in keep_indices:
                    continue

                # Calculate IoU
                iou = self._calculate_iou(detections[i]["bbox"], detections[j]["bbox"])

                if iou > self.overlap_threshold:
                    # Keep the detection with higher confidence
                    if detections[i]["score"] >= detections[j]["score"]:
                        keep_indices.discard(j)
                        overlaps_removed += 1
                        self.logger.debug(
                            f"Frame {frame_id}: Removed overlapping track {detections[j]['track_id']} "
                            f"(IoU {iou:.2f} with track {detections[i]['track_id']})"
                        )
                    else:
                        keep_indices.discard(i)
                        overlaps_removed += 1
                        self.logger.debug(
                            f"Frame {frame_id}: Removed overlapping track {detections[i]['track_id']} "
                            f"(IoU {iou:.2f} with track {detections[j]['track_id']})"
                        )
                        break

        if overlaps_removed > 0:
            self.overlap_count += overlaps_removed
            self.logger.info(
                f"Frame {frame_id}: Removed {overlaps_removed} overlapping boxes"
            )

        return [detections[i] for i in sorted(keep_indices)]

    def _consolidate_track_ids(
        self, detections: List[Dict], current_gps: Optional["GPSData"]
    ) -> List[Dict]:
        """Enhanced consolidation with persistent memory"""

        for detection in detections:
            original_id = detection["track_id"]

            # Get stable consolidated ID
            consolidated_id = self._get_consolidated_id(detection, current_gps)

            # Update detection
            detection["original_track_id"] = original_id
            detection["track_id"] = consolidated_id

            if original_id != consolidated_id:
                self.fixed_count += 1

        return detections

    def _consolidate_track_ids_bkp(
        self, detections: List[Dict], current_gps: Optional["GPSData"]
    ) -> List[Dict]:
        """Consolidate track IDs to prevent multiple IDs for same object"""

        for detection in detections:
            original_id = detection["track_id"]

            # Get consolidated ID
            consolidated_id = self._get_consolidated_id(detection, current_gps)

            # Update detection
            detection["original_track_id"] = original_id
            detection["track_id"] = consolidated_id

            if original_id != consolidated_id:
                self.fixed_count += 1
                self.logger.info(
                    f"Frame {detection['frame']}: Consolidated track {original_id} â†’ {consolidated_id}"
                )

        return detections

    def _get_consolidated_id(
        self, detection: Dict, current_gps: Optional["GPSData"]
    ) -> int:
        """Enhanced consolidation with persistent memory"""
        original_id = detection["track_id"]
        detection_center = np.array(
            [
                (detection["bbox"][0] + detection["bbox"][2]) / 2,
                (detection["bbox"][1] + detection["bbox"][3]) / 2,
            ]
        )

        # Check if we've seen this ultralytics ID before
        if original_id in self.persistent_id_mapping:
            stable_id = self.persistent_id_mapping[original_id]
            self.logger.info(f"Reusing known mapping: {original_id} -> {stable_id}")

            # Update position history
            if stable_id not in self.id_position_history:
                self.id_position_history[stable_id] = []
            self.id_position_history[stable_id].append(detection_center)

            # Keep only recent positions
            if len(self.id_position_history[stable_id]) > 10:
                self.id_position_history[stable_id] = self.id_position_history[
                    stable_id
                ][-10:]

            return stable_id

        # Check if this detection is close to any existing stable track
        best_match_id = None
        best_distance = float("inf")

        for stable_id, positions in self.id_position_history.items():
            if not positions:
                continue

            # Check distance to most recent positions
            recent_positions = positions[-3:]  # Last 3 positions
            for pos in recent_positions:
                distance = np.linalg.norm(detection_center - pos)

                # Use spatial proximity to identify same object
                if distance < 50.0 and distance < best_distance:  # 50px tolerance
                    best_match_id = stable_id
                    best_distance = distance

        if best_match_id is not None:
            # Map to existing stable ID
            self.persistent_id_mapping[original_id] = best_match_id
            self.id_position_history[best_match_id].append(detection_center)
            self.logger.info(
                f"Spatial match: {original_id} -> {best_match_id} (distance: {best_distance:.1f}px)"
            )
            return best_match_id

        # Create new stable ID
        new_stable_id = self.stable_id_counter
        self.stable_id_counter += 1

        self.persistent_id_mapping[original_id] = new_stable_id
        self.id_position_history[new_stable_id] = [detection_center]

        self.logger.info(f"New stable ID: {original_id} -> {new_stable_id}")
        return new_stable_id

    def _get_consolidated_id_bkp(
        self, detection: Dict, current_gps: Optional["GPSData"]
    ) -> int:
        """Get consolidated track ID for detection"""
        original_id = detection["track_id"]

        # If we've seen this original ID before, return its mapping
        if original_id in self.id_mapping:
            return self.id_mapping[original_id]

        # Check if this detection is close to any existing tracks (if we have GPS)
        if current_gps:
            detection_gps = self._estimate_detection_gps(detection, current_gps)

            if detection_gps:
                # Find existing tracks within distance threshold
                for existing_id, positions in self.track_positions.items():
                    if not positions:
                        continue

                    # Check distance to most recent position
                    recent_pos = positions[-1]
                    distance = self._gps_distance(
                        detection_gps[0],
                        detection_gps[1],
                        recent_pos["lat"],
                        recent_pos["lon"],
                    )

                    if distance <= self.distance_threshold:
                        # Merge with existing track
                        self.id_mapping[original_id] = existing_id

                        # Add position to existing track
                        self.track_positions[existing_id].append(
                            {
                                "lat": detection_gps[0],
                                "lon": detection_gps[1],
                                "frame": detection["frame"],
                            }
                        )

                        self.logger.info(
                            f"Merged track {original_id} into {existing_id} (distance: {distance:.1f}m)"
                        )
                        return existing_id

        # This is a genuinely new track
        new_consolidated_id = self.next_consolidated_id
        self.id_mapping[original_id] = new_consolidated_id
        self.next_consolidated_id += 1

        # Initialize position tracking
        if current_gps:
            detection_gps = self._estimate_detection_gps(detection, current_gps)
            if detection_gps:
                self.track_positions[new_consolidated_id] = [
                    {
                        "lat": detection_gps[0],
                        "lon": detection_gps[1],
                        "frame": detection["frame"],
                    }
                ]

        return new_consolidated_id

    def _estimate_detection_gps(
        self, detection: Dict, gps: "GPSData"
    ) -> Optional[Tuple[float, float]]:
        """Estimate GPS coordinates for detection (simplified version)"""
        try:
            bbox = detection["bbox"]
            bbox_height = bbox[3] - bbox[1]

            if bbox_height <= 0:
                return None

            # Simple depth estimation
            focal_length = 1400
            lightpost_height = 4.0
            estimated_depth = (lightpost_height * focal_length) / bbox_height

            # GPS calculation (simplified)
            bbox_center_x = (bbox[0] + bbox[2]) / 2
            image_width = 1920  # Assume standard width

            pixels_from_center = bbox_center_x - (image_width / 2)
            degrees_per_pixel = 60.0 / image_width
            bearing_offset = pixels_from_center * degrees_per_pixel
            object_bearing = gps.heading + bearing_offset

            import math

            lat_offset = (
                estimated_depth * math.cos(math.radians(object_bearing))
            ) / 111000
            lon_offset = (estimated_depth * math.sin(math.radians(object_bearing))) / (
                111000 * math.cos(math.radians(gps.latitude))
            )

            object_lat = gps.latitude + lat_offset
            object_lon = gps.longitude + lon_offset

            return (object_lat, object_lon)

        except Exception:
            return None

    def _calculate_iou(self, box1: np.ndarray, box2: np.ndarray) -> float:
        """Calculate IoU between two bounding boxes"""
        x1 = max(box1[0], box2[0])
        y1 = max(box1[1], box2[1])
        x2 = min(box1[2], box2[2])
        y2 = min(box1[3], box2[3])

        intersection = max(0, x2 - x1) * max(0, y2 - y1)
        area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])
        area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])
        union = area1 + area2 - intersection

        return intersection / union if union > 0 else 0

    def _gps_distance(
        self, lat1: float, lon1: float, lat2: float, lon2: float
    ) -> float:
        """Calculate distance between GPS points in meters"""
        R = 6378137.0
        lat1_rad = np.radians(lat1)
        lat2_rad = np.radians(lat2)
        dlat = np.radians(lat2 - lat1)
        dlon = np.radians(lon2 - lon1)

        a = (
            np.sin(dlat / 2) ** 2
            + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin(dlon / 2) ** 2
        )
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))

        return R * c

    def get_statistics(self) -> Dict:
        """Get overlap fixing statistics"""
        return {
            "overlaps_removed": self.overlap_count,
            "ids_consolidated": self.fixed_count,
            "unique_tracks": len(set(self.id_mapping.values())),
            "original_tracks": len(self.id_mapping),
        }

================
File: README.md
================
# Argus Track: Enhanced Stereo Tracking with Automatic GPS Extraction

A specialized implementation of ByteTrack optimized for tracking light posts and static infrastructure in **stereo video sequences** with **automatic GPS extraction from GoPro videos**. Features **3D triangulation**, **integrated GPS processing**, and **1-2 meter geolocation accuracy** for mapping and asset management.

## ðŸŽ¯ Key Features

- **ðŸ” Stereo Vision Processing**: 3D triangulation from stereo camera pairs for accurate depth estimation
- **ðŸ›°ï¸ Automatic GPS Extraction**: Extract GPS data directly from GoPro video metadata (no separate GPS file needed!)
- **ðŸ“ Precise Geolocation**: 1-2 meter accuracy GPS coordinate estimation for tracked objects  
- **ðŸš¦ Infrastructure Focus**: Optimized for light posts, traffic signals, and static infrastructure
- **ðŸ§  YOLOv11 Support**: Advanced object detection with latest YOLO architecture
- **ðŸ“¡ GPS Synchronization**: Smart GPS frame processing (60fps video â†’ 10fps GPS alignment)
- **ðŸŽ¥ GoPro Optimized**: Designed for GoPro Hero 11 stereo camera setups with embedded GPS
- **ðŸ“Š Multiple Export Formats**: JSON, GeoJSON, and CSV outputs for GIS integration

## ðŸš€ Quick Start

### Installation

```bash
# Clone repository
git clone https://github.com/Bell-South/ArgusTrack.git
cd ArgusTrack

# Install dependencies (including GPS extraction tools)
pip install -r argus_track/requirements.txt

# Install ExifTool (required for GPS extraction)
# Windows: Download from https://exiftool.org/
# macOS: brew install exiftool  
# Linux: sudo apt-get install libimage-exiftool-perl

# Install package
pip install -e .
```

### ðŸŽ¬ Complete Example (With Your Files)

```bash
# Enhanced stereo tracking with automatic GPS extraction
argus_track --stereo left_camera.mp4 right_camera.mp4 \
    --calibration stereo_calibration.pkl \
    --detector yolov11 \
    --model your_finetuned_model.pt \
    --auto-gps \
    --output tracked_result.mp4
```

**That's it!** No need to extract GPS separately - it's automatic! ðŸŽ‰

### ðŸ“ Required Files

```
your_project/
â”œâ”€â”€ left_camera.mp4              # Left camera video (with GPS metadata)
â”œâ”€â”€ right_camera.mp4             # Right camera video  
â”œâ”€â”€ stereo_calibration.pkl       # Your calibration file
â””â”€â”€ your_finetuned_model.pt     # Your fine-tuned YOLOv11 model
```

## ðŸ›°ï¸ GPS Extraction Methods

The system automatically tries multiple methods to extract GPS data from your videos:

### Method 1: ExifTool (Recommended)
- âœ… Works with most GoPro videos
- âœ… High accuracy GPS extraction
- âœ… Extracts full GPS tracks from metadata

### Method 2: GoPro API
- âœ… Official GoPro telemetry extraction
- âœ… Best accuracy when available
- âš ï¸ Requires `gopro-overlay` package

### Method 3: Auto Detection
- ðŸ”„ Tries ExifTool first, falls back to GoPro API
- ðŸ”„ Automatically handles different video formats

## ðŸ“ Usage Examples

### 1. Complete Automatic Processing

```bash
# Everything automatic - GPS extraction, tracking, geolocation
argus_track --stereo left.mp4 right.mp4 \
    --calibration calibration.pkl \
    --detector yolov11 \
    --model model.pt \
    --auto-gps
```

### 2. Extract GPS Only (No Tracking)

```bash
# Just extract GPS data to CSV
argus_track --extract-gps-only left.mp4 right.mp4 \
    --output gps_data.csv \
    --gps-method exiftool
```

### 3. Use Existing GPS File

```bash
# Use pre-extracted GPS file
argus_track --stereo left.mp4 right.mp4 \
    --calibration calibration.pkl \
    --gps existing_gps.csv \
    --detector yolov11 \
    --model model.pt
```

### 4. Python API Usage

```python
from argus_track import (
    TrackerConfig, StereoCalibrationConfig, 
    YOLOv11Detector
)
from argus_track.trackers.stereo_lightpost_tracker import EnhancedStereoLightPostTracker

# Load calibration
stereo_calibration = StereoCalibrationConfig.from_pickle('calibration.pkl')

# Initialize detector with your fine-tuned model
detector = YOLOv11Detector(
    model_path='your_model.pt',
    target_classes=['light_post', 'traffic_signal', 'pole'],
    device='auto'
)

# Configure tracker
config = TrackerConfig(
    track_thresh=0.4,
    stereo_mode=True,
    gps_frame_interval=6
)

# Initialize enhanced tracker
tracker = EnhancedStereoLightPostTracker(
    config=config,
    detector=detector,
    stereo_calibration=stereo_calibration
)

# Process with automatic GPS extraction
tracks = tracker.process_stereo_video_with_auto_gps(
    left_video_path='left.mp4',
    right_video_path='right.mp4',
    save_results=True
)

# Get results
stats = tracker.get_enhanced_tracking_statistics()
print(f"GPS extraction method: {stats['gps_extraction_method']}")
print(f"Average accuracy: {stats['accuracy_achieved']:.1f}m")
print(f"Locations found: {stats['estimated_locations']}")
```

## ðŸ“Š Output Files

After processing, you get:

### 1. **GPS Data (Automatic)**
- `left_camera.csv` - Extracted GPS data in CSV format
- ðŸ“¡ Contains: timestamp, latitude, longitude, altitude, heading, accuracy

### 2. **Tracking Results**  
- `left_camera.json` - Complete tracking data with 3D trajectories
- ðŸ“¹ Contains: tracks, stereo detections, depth info, processing stats

### 3. **Geolocation Map**
- `left_camera.geojson` - GPS locations ready for GIS software
- ðŸ—ºï¸ Contains: precise coordinates, accuracy, reliability scores

### 4. **Visualization Video**
- `tracked_result.mp4` - Side-by-side stereo tracking visualization
- ðŸŽ¬ Shows: bounding boxes, track IDs, trajectories

## ðŸŽ¯ Accuracy Results

The system provides detailed accuracy metrics:

```bash
=== TRACKING RESULTS ===
ðŸ“¹ Total stereo tracks: 12
ðŸ—ï¸  Static tracks: 8
ðŸ“ Estimated locations: 8
ðŸ›°ï¸  GPS extraction method: exiftool
ðŸ“¡ GPS points used: 450
ðŸ“ Average depth: 25.4m
ðŸŽ¯ Average accuracy: 1.2m
âœ… Average reliability: 0.94

ðŸ† TARGET ACHIEVED: Average accuracy â‰¤ 2 meters!
```

### Accuracy Interpretation:
- **ðŸŽ¯ < 2m**: Excellent accuracy (target achieved)
- **âœ… 2-5m**: Good accuracy for most applications  
- **âš ï¸ > 5m**: Consider recalibration or GPS quality check

## ðŸ”§ Configuration

### Stereo Configuration (`stereo_config.yaml`)

```yaml
# Tracking parameters
track_thresh: 0.4              # Lower for fine-tuned models
match_thresh: 0.8
stereo_mode: true
gps_frame_interval: 6          # 60fps -> 10fps GPS sync

# Your fine-tuned detector
detector:
  model_type: "yolov11"
  model_path: "your_model.pt"
  target_classes:              # YOUR CLASSES
    - "light_post"
    - "traffic_signal" 
    - "utility_pole"
    - "street_light"

# GPS extraction
gps_extraction:
  method: "auto"               # auto, exiftool, gopro_api
  accuracy_threshold: 5.0      # Ignore GPS > 5m accuracy
```

## ðŸ› ï¸ Comparison with Your Original Code

Your original GPS extraction code has been **fully integrated** into Argus Track:

| Your Original Code | Argus Track Integration |
|-------------------|------------------------|
| âœ… ExifTool GPS extraction | âœ… **Enhanced** ExifTool method |
| âœ… Track4 GPS parsing | âœ… **Improved** metadata parsing |
| âœ… DMS coordinate conversion | âœ… **Robust** coordinate handling |
| âœ… Frame synchronization | âœ… **Advanced** stereo-GPS sync |
| âŒ No 3D tracking | âœ… **Added** stereo tracking |
| âŒ No geolocation | âœ… **Added** 1-2m accuracy |
| âŒ Manual process | âœ… **Automatic** end-to-end |

## ðŸ“‹ Processing Pipeline

```
GoPro Videos (with GPS) â†’ GPS Extraction â†’ Stereo Processing â†’ 3D Tracking â†’ Geolocation
     â†“                         â†“                â†“               â†“            â†“
Left/Right MP4          GPS Metadata      Object Detection  ByteTrack     GPS Coords
60fps + 10Hz GPS    â†’   CSV Export    â†’   YOLOv11        â†’  3D Tracks  â†’  1-2m Accuracy
```

## ðŸš¨ Troubleshooting

### GPS Extraction Issues

```bash
# Check if ExifTool is installed
exiftool -ver

# Test GPS extraction on single video
argus_track --extract-gps-only left.mp4 right.mp4 --verbose

# Check video metadata
exiftool -G -a -s left.mp4 | grep GPS
```

### Accuracy Issues

```python
# Check calibration quality
from argus_track.stereo import StereoCalibrationManager
calib = StereoCalibrationManager.from_pickle_file('calibration.pkl')
print("Calibration valid:", calib.validate_calibration()[0])
```

### Detection Issues

```python
# Test your model
from argus_track import YOLOv11Detector
detector = YOLOv11Detector('your_model.pt')
print("Model classes:", detector.get_class_names())
```

## ðŸŒŸ Advanced Features

### Real-time Processing

```python
# Process live stereo stream (conceptual)
def process_live_stereo():
    while True:
        left_frame, right_frame = get_stereo_frames()
        current_gps = get_current_gps()
        
        tracks = tracker.process_frame_pair(
            left_frame, right_frame, current_gps
        )
```

### Batch Processing

```bash
# Process multiple video pairs
for video_pair in /data/videos/*/; do
    argus_track --stereo "$video_pair"/{left,right}.mp4 \
        --calibration calibration.pkl \
        --model model.pt \
        --auto-gps
done
```

### GIS Integration

```python
# Load results in QGIS/ArcGIS
import geopandas as gpd
gdf = gpd.read_file('results.geojson')
print(f"Found {len(gdf)} light posts")
```

## ðŸ“ž Support

- **Documentation**: [Complete usage guide](docs/USAGE_GUIDE.md)
- **Issues**: [GitHub Issues](https://github.com/Bell-South/ArgusTrack/issues)
- **Examples**: [examples/](examples/) directory

## ðŸŽ¯ Summary

Argus Track now provides a **complete solution** for your light post mapping needs:

1. **ðŸŽ¬ Input**: Your stereo GoPro videos (with embedded GPS)
2. **ðŸ”„ Process**: Automatic GPS extraction + stereo tracking + 3D triangulation  
3. **ðŸ“ Output**: 1-2 meter accurate GPS coordinates of light posts
4. **ðŸ“Š Export**: Ready for GIS software and mapping applications

**No manual GPS extraction needed - everything is automatic!** ðŸš€

---

*Argus Track: From GoPro videos to precise infrastructure maps* ðŸŽ¯ðŸ“

================
File: setup.py
================
"""
Setup script for ByteTrack Light Post Tracking System
"""

from setuptools import setup, find_packages
import os

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

# Try to read requirements from multiple locations
requirements = []
possible_req_files = [
    "requirements.txt",
    "argus_track/requirements.txt"
]

for req_file in possible_req_files:
    if os.path.exists(req_file):
        with open(req_file, "r", encoding="utf-8") as fh:
            requirements = [
                line.strip() 
                for line in fh 
                if line.strip() and not line.startswith("#")
            ]
        break

# If no requirements file found, use minimal requirements
if not requirements:
    requirements = [
        "numpy>=1.19.0",
        "scipy>=1.5.0",
        "opencv-python>=4.5.0",
        "matplotlib>=3.3.0",
        "pyyaml>=5.4.0",
        "pandas>=1.3.0",
        "Pillow>=8.0.0",
        "beautifulsoup4>=4.9.0",
        "lxml>=4.6.0",
        "python-dateutil>=2.8.0",
        "psutil>=5.8.0"
    ]

setup(
    name="argus-track",
    version="1.0.0",
    author="Light Post Tracking Team",
    author_email="joaquin.olivera@gmail.com",
    description="ByteTrack implementation optimized for light post tracking with GPS integration",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/Bell-South/ArgusTrack.git",
    packages=find_packages(exclude=["tests", "docs", "examples"]),
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "Topic :: Scientific/Engineering :: Artificial Intelligence",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
    ],
    python_requires=">=3.8",
    install_requires=requirements,
    extras_require={
        "dev": [
            "pytest>=6.0.0",
            "black>=21.0",
            "mypy>=0.910",
        ],
        "docs": [
            "sphinx>=4.0.0",
            "sphinx-rtd-theme>=0.5.0",
        ],
        "gpu": [
            "torch>=1.9.0",
            "torchvision>=0.10.0",
        ],
    },
    entry_points={
        "console_scripts": [
            "argus_track=argus_track.main:main",
        ],
    },
    include_package_data=True,
    package_data={
        "argus_track": ["config/*.yaml", "config/*.json"],
    },
)

================
File: argus_track/detectors/__init__.py
================
"""Object detectors for ByteTrack system"""

from .base import ObjectDetector
from .yolov11 import YOLOv11Detector

__all__ = ["ObjectDetector", "YOLOv11Detector"]

================
File: argus_track/detectors/yolov11.py
================
# argus_track/detectors/yolov11.py (FIXED)
"""YOLOv11 detector implementation with proper class handling"""

import logging
from typing import Any, Dict, List, Optional

import cv2
import numpy as np
import torch

from .base import ObjectDetector


class YOLOv11Detector(ObjectDetector):
    """YOLOv11-based object detector implementation with PyTorch backend"""

    def __init__(
        self,
        model_path: str,
        target_classes: Optional[List[str]] = None,
        confidence_threshold: float = 0.5,
        nms_threshold: float = 0.4,
        device: str = "auto",
        input_size: int = 640,
    ):
        """
        Initialize YOLOv11 detector

        Args:
            model_path: Path to YOLOv11 model file (.pt)
            target_classes: List of class names to detect (None for all)
            confidence_threshold: Minimum confidence for detections
            nms_threshold: Non-maximum suppression threshold
            device: Device to use ('cpu', 'cuda', or 'auto')
            input_size: Model input size (typically 640)
        """
        self.logger = logging.getLogger(f"{__name__}.YOLOv11Detector")
        self.model_path = model_path
        self.confidence_threshold = confidence_threshold
        self.nms_threshold = nms_threshold
        self.input_size = input_size

        # Set device
        if device == "auto":
            self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        else:
            self.device = torch.device(device)

        self.logger.info(f"Using device: {self.device}")

        # Load model
        self.model = self._load_model()

        # Get class names directly from the loaded model
        self.class_names = list(self.model.names.values())
        self.logger.info(f"Model classes: {dict(self.model.names)}")

        # Set target classes - FIXED: Now handles all classes properly
        if target_classes is None:
            self.target_classes = self.class_names.copy()
            self.logger.info(f"Using all model classes: {self.target_classes}")
        else:
            # Filter to only valid classes that exist in the model
            valid_classes = [cls for cls in target_classes if cls in self.class_names]
            if not valid_classes:
                self.logger.warning(
                    f"None of the target classes {target_classes} found in model. Using all model classes."
                )
                self.target_classes = self.class_names.copy()
            else:
                self.target_classes = valid_classes
                self.logger.info(
                    f"Using filtered target classes: {self.target_classes}"
                )

        # Target class indices - FIXED: Now maps to actual class names
        self.target_class_indices = [
            i for i, name in enumerate(self.class_names) if name in self.target_classes
        ]

        self.logger.info(
            f"Initialized YOLOv11 detector with {len(self.target_classes)} target classes"
        )
        self.logger.info(f"Target class indices: {self.target_class_indices}")

    def _load_model(self):
        """Load YOLOv11 model"""
        try:
            # Try to load with ultralytics (if available)
            try:
                from ultralytics import YOLO

                model = YOLO(self.model_path)
                model.to(self.device)
                self.logger.info("Loaded YOLOv11 model using ultralytics")
                return model
            except ImportError:
                self.logger.warning(
                    "ultralytics not available, falling back to torch.hub"
                )

            # Fallback to torch.hub or direct torch loading
            if self.model_path.endswith(".pt"):
                model = torch.jit.load(self.model_path, map_location=self.device)
                model.eval()
                self.logger.info("Loaded YOLOv11 model using torch.jit")
                return model
            else:
                raise ValueError(f"Unsupported model format: {self.model_path}")

        except Exception as e:
            self.logger.error(f"Failed to load YOLOv11 model: {e}")
            raise

    def detect(self, frame: np.ndarray) -> List[Dict[str, Any]]:
        """
        Detect objects in frame using YOLOv11

        Args:
            frame: Input image

        Returns:
            List of detections
        """
        try:
            # Check if using ultralytics YOLO
            if hasattr(self.model, "predict"):
                return self._detect_ultralytics(frame)
            else:
                return self._detect_torch(frame)
        except Exception as e:
            self.logger.error(f"Detection failed: {e}")
            return []

    def _detect_ultralytics(self, frame: np.ndarray) -> List[Dict[str, Any]]:
        """Detection using ultralytics YOLO - FIXED to handle all classes"""

        # Run inference with low confidence to catch all possible detections
        results = self.model.predict(
            frame,
            conf=0.001,  # Very low confidence to catch everything
            iou=self.nms_threshold,
            verbose=False,
        )

        detections = []

        if results and len(results) > 0:
            result = results[0]

            if result.boxes is not None:
                boxes = result.boxes.xyxy.cpu().numpy()
                scores = result.boxes.conf.cpu().numpy()
                classes = result.boxes.cls.cpu().numpy().astype(int)

                self.logger.debug(
                    f"Raw detections: {len(boxes)} boxes, classes: {set(classes)}"
                )

                for i, (box, score, cls_id) in enumerate(zip(boxes, scores, classes)):
                    # FIXED: Check if class is in our target classes instead of hardcoded check
                    if cls_id < len(self.class_names):
                        class_name = self.class_names[cls_id]

                        # Only keep detections of target classes with sufficient confidence
                        if (
                            class_name in self.target_classes
                            and score >= self.confidence_threshold
                        ):

                            detections.append(
                                {
                                    "bbox": box.tolist(),
                                    "score": float(score),
                                    "class_name": class_name,
                                    "class_id": cls_id,
                                }
                            )

                            self.logger.debug(
                                f"Kept detection: {class_name} (ID:{cls_id}), Conf: {score:.4f}"
                            )
                        else:
                            self.logger.debug(
                                f"Filtered out: {class_name} (ID:{cls_id}), Conf: {score:.4f}"
                            )
                    else:
                        self.logger.warning(f"Invalid class ID: {cls_id}")

        self.logger.debug(f"Final detections: {len(detections)}")
        return detections

    def _detect_torch(self, frame: np.ndarray) -> List[Dict[str, Any]]:
        """Detection using pure PyTorch model"""
        # Preprocess image
        input_tensor = self._preprocess_image(frame)

        # Run inference
        with torch.no_grad():
            predictions = self.model(input_tensor)

        # Post-process results
        detections = self._postprocess_predictions(predictions, frame.shape)

        return detections

    def _preprocess_image(self, frame: np.ndarray) -> torch.Tensor:
        """Preprocess image for YOLOv11"""
        # Resize to model input size
        height, width = frame.shape[:2]

        # Calculate scale factor
        scale = min(self.input_size / width, self.input_size / height)
        new_width = int(width * scale)
        new_height = int(height * scale)

        # Resize image
        resized = cv2.resize(frame, (new_width, new_height))

        # Pad to square
        top = (self.input_size - new_height) // 2
        bottom = self.input_size - new_height - top
        left = (self.input_size - new_width) // 2
        right = self.input_size - new_width - left

        padded = cv2.copyMakeBorder(
            resized,
            top,
            bottom,
            left,
            right,
            cv2.BORDER_CONSTANT,
            value=(114, 114, 114),
        )

        # Convert to tensor
        image_tensor = torch.from_numpy(padded).permute(2, 0, 1).float()
        image_tensor /= 255.0  # Normalize to [0, 1]

        # Add batch dimension
        image_tensor = image_tensor.unsqueeze(0).to(self.device)

        return image_tensor

    def _postprocess_predictions(
        self, predictions: torch.Tensor, original_shape: tuple
    ) -> List[Dict[str, Any]]:
        """Post-process YOLOv11 predictions"""
        detections = []

        # Assuming predictions shape: [batch, num_boxes, 85] (x, y, w, h, conf, classes...)
        pred = predictions[0]  # Remove batch dimension

        # Filter by confidence
        conf_mask = pred[:, 4] >= self.confidence_threshold
        pred = pred[conf_mask]

        if len(pred) == 0:
            return detections

        # Convert boxes from center format to corner format
        boxes = pred[:, :4].clone()
        boxes[:, 0] = pred[:, 0] - pred[:, 2] / 2  # x1 = cx - w/2
        boxes[:, 1] = pred[:, 1] - pred[:, 3] / 2  # y1 = cy - h/2
        boxes[:, 2] = pred[:, 0] + pred[:, 2] / 2  # x2 = cx + w/2
        boxes[:, 3] = pred[:, 1] + pred[:, 3] / 2  # y2 = cy + h/2

        # Scale boxes back to original image size
        scale_x = original_shape[1] / self.input_size
        scale_y = original_shape[0] / self.input_size

        boxes[:, [0, 2]] *= scale_x
        boxes[:, [1, 3]] *= scale_y

        # Get class predictions
        class_probs = pred[:, 5:]
        class_ids = torch.argmax(class_probs, dim=1)
        max_class_probs = torch.max(class_probs, dim=1)[0]

        # Apply NMS
        keep_indices = torchvision.ops.nms(
            boxes,
            pred[:, 4] * max_class_probs,  # Combined confidence
            self.nms_threshold,
        )

        # Filter results
        final_boxes = boxes[keep_indices]
        final_scores = pred[keep_indices, 4]
        final_classes = class_ids[keep_indices]

        # Convert to detection format
        for box, score, cls_id in zip(final_boxes, final_scores, final_classes):
            cls_id = int(cls_id.item())

            # Filter by target classes - FIXED: Now uses proper class checking
            if cls_id < len(self.class_names):
                class_name = self.class_names[cls_id]

                if class_name in self.target_classes:
                    detections.append(
                        {
                            "bbox": box.cpu().numpy().tolist(),
                            "score": float(score.item()),
                            "class_name": class_name,
                            "class_id": cls_id,
                        }
                    )

        return detections

    def get_class_names(self) -> List[str]:
        """Get list of detectable class names"""
        return self.class_names.copy()

    def set_confidence_threshold(self, threshold: float) -> None:
        """Set detection confidence threshold"""
        self.confidence_threshold = threshold
        self.logger.info(f"Updated confidence threshold to {threshold}")

    def set_nms_threshold(self, threshold: float) -> None:
        """Set NMS threshold"""
        self.nms_threshold = threshold
        self.logger.info(f"Updated NMS threshold to {threshold}")

    def get_model_info(self) -> Dict[str, Any]:
        """Get model information"""
        return {
            "model_path": self.model_path,
            "device": str(self.device),
            "input_size": self.input_size,
            "confidence_threshold": self.confidence_threshold,
            "nms_threshold": self.nms_threshold,
            "target_classes": self.target_classes,
            "num_classes": len(self.class_names),
            "all_classes": dict(enumerate(self.class_names)),
        }

================
File: argus_track/utils/__init__.py
================
"""Utility functions for ByteTrack system"""

from .gps_utils import CoordinateTransformer, GPSInterpolator
from .io import load_gps_data, save_tracking_results, setup_logging
from .iou import calculate_iou, calculate_iou_matrix
from .output_manager import FrameData, OutputManager
from .overlap_fixer import OverlapFixer
from .smart_track_manager import CleanTrackManager, TrackMemory
from .static_car_detector import StaticCarDetector, create_static_car_detector
from .visualization import create_track_overlay, draw_tracks

__all__ = [
    "calculate_iou",
    "calculate_iou_matrix",
    "draw_tracks",
    "create_track_overlay",
    "save_tracking_results",
    "load_gps_data",
    "setup_logging",
    "GPSInterpolator",
    "StaticCarDetector",
    "OutputManager",
    "FrameData",
    "CleanTrackManager",
    "TrackMemory",
    "create_static_car_detector",
    "OverlapFixer",
    "CoordinateTransformer",
]

================
File: argus_track/utils/visualization.py
================
"""Enhanced visualization utilities with real-time display"""

import logging
import time
from typing import Dict, List, Optional, Tuple

import cv2
import numpy as np

from ..core import Detection, Track

# Color palette for different track states
TRACK_COLORS = {
    "tentative": (255, 255, 0),  # Yellow
    "confirmed": (0, 255, 0),  # Green
    "lost": (0, 0, 255),  # Red
    "removed": (128, 128, 128),  # Gray
}

# Class-specific colors
CLASS_COLORS = {
    "Led-150": (255, 0, 0),  # Red
    "Led-240": (0, 0, 255),  # Blue
    "light_post": (0, 255, 0),  # Green
    "street_light": (255, 165, 0),  # Orange
    "pole": (128, 0, 128),  # Purple
}


class RealTimeVisualizer:
    """Real-time visualization during tracking"""

    def __init__(
        self,
        window_name: str = "Argus Track - Real-time Detection",
        display_size: Tuple[int, int] = (1280, 720),
        show_info_panel: bool = True,
    ):
        """
        Initialize real-time visualizer

        Args:
            window_name: Name of the display window
            display_size: Size of the display window (width, height)
            show_info_panel: Whether to show information panel
        """
        self.window_name = window_name
        self.display_size = display_size
        self.show_info_panel = show_info_panel

        # Initialize logger
        self.logger = logging.getLogger(f"{__name__}.RealTimeVisualizer")

        # Statistics tracking
        self.frame_count = 0
        self.detection_history = []
        self.fps_history = []
        self.last_time = time.time()

        # Create window
        cv2.namedWindow(self.window_name, cv2.WINDOW_NORMAL)
        cv2.resizeWindow(self.window_name, display_size[0], display_size[1])

        # Create default blank frame for error cases
        self.blank_frame = np.zeros(
            (display_size[1], display_size[0], 3), dtype=np.uint8
        )
        cv2.putText(
            self.blank_frame,
            "No frame data available",
            (display_size[0] // 4, display_size[1] // 2),
            cv2.FONT_HERSHEY_SIMPLEX,
            1,
            (255, 255, 255),
            2,
        )

        self.logger.info(f"ðŸ–¥ï¸  Real-time visualization window opened: {window_name}")
        self.logger.info("   Press 'q' to quit, 'p' to pause, 's' to save screenshot")

    def _add_info_panel(
        self,
        frame: np.ndarray,
        detections: List[Detection],
        tracks: List[Track],
        gps_data: Optional[Dict] = None,
        frame_info: Optional[Dict] = None,
    ) -> np.ndarray:
        """Enhanced information panel with motion prediction and visual feature info"""

        if frame is None or not isinstance(frame, np.ndarray) or len(frame.shape) != 3:
            return self.blank_frame.copy()

        try:
            # Create larger panel for enhanced info
            panel_height = 200  # Increased height
            panel_width = 400  # Increased width

            # Create semi-transparent overlay
            overlay = frame.copy()
            cv2.rectangle(
                overlay,
                (frame.shape[1] - panel_width - 10, 10),
                (frame.shape[1] - 10, panel_height + 10),
                (0, 0, 0),
                -1,
            )

            # Blend with original frame
            result = cv2.addWeighted(frame, 0.7, overlay, 0.3, 0)

            # Safety checks
            if detections is None:
                detections = []
            if tracks is None:
                tracks = []
            if frame_info is None:
                frame_info = {}

            # Enhanced info lines
            y_offset = 35
            text_color = (255, 255, 255)
            font = cv2.FONT_HERSHEY_SIMPLEX
            font_scale = 0.5
            small_font_scale = 0.4

            # === BASIC INFO ===
            info_lines = [
                f"Frame: {frame_info.get('frame_idx', self.frame_count)}",
                f"Detections: {len(detections)}",
                f"Active Tracks: {len([t for t in tracks if getattr(t, 'state', None) in ['tentative', 'confirmed']])}",
            ]

            # === MOTION PREDICTION INFO ===
            if frame_info.get("motion_prediction_enabled", False):
                motion_detected = (
                    "YES" if frame_info.get("camera_motion_detected", False) else "NO"
                )
                pred_accuracy = frame_info.get("avg_prediction_accuracy", 0)
                info_lines.extend(
                    [
                        f"Motion Pred: {motion_detected} ({pred_accuracy:.2f})",
                    ]
                )

            # === VISUAL FEATURES INFO ===
            if frame_info.get("visual_features_enabled", False):
                tracks_with_features = frame_info.get("tracks_with_features", 0)
                appearance_stability = frame_info.get("avg_appearance_stability", 0)
                info_lines.extend(
                    [
                        f"Visual Features: {tracks_with_features} tracks",
                        f"Appearance Stability: {appearance_stability:.2f}",
                    ]
                )

            # === DETECTION TYPE BREAKDOWN ===
            motion_compensated = len(
                [d for d in detections if getattr(d, "motion_compensated", False)]
            )
            prediction_matches = len(
                [d for d in detections if getattr(d, "prediction_match", False)]
            )
            reappearances = len(
                [d for d in detections if getattr(d, "reappearance_match", False)]
            )

            if motion_compensated > 0 or prediction_matches > 0 or reappearances > 0:
                info_lines.append(
                    f"Enhanced: MC:{motion_compensated} P:{prediction_matches} R:{reappearances}"
                )

            # === GPS INFO ===
            if gps_data:
                gps_data.get("vehicle_speed_ms", 0)
                speed_kmh = gps_data.get("vehicle_speed_kmh", 0)
                info_lines.extend(
                    [
                        f"GPS: {gps_data.get('latitude', 0):.5f}",
                        f"     {gps_data.get('longitude', 0):.5f}",
                        f"Speed: {speed_kmh:.1f} km/h",
                        f"Heading: {gps_data.get('heading', 0):.1f}Â°",
                    ]
                )

            # === TRACK CONSOLIDATION INFO ===
            consolidations = frame_info.get("track_consolidations", 0)
            reappearances_total = frame_info.get("track_reappearances", 0)
            if consolidations > 0 or reappearances_total > 0:
                info_lines.append(f"Consolidations: {consolidations}")
                info_lines.append(f"Reappearances: {reappearances_total}")

            # === PERFORMANCE INFO ===
            processed_frames = frame_info.get("processed_frames", 0)
            total_frames = frame_info.get("total_frames", 1)
            efficiency = (
                (processed_frames / total_frames * 100) if total_frames > 0 else 0
            )
            info_lines.append(f"Efficiency: {efficiency:.1f}%")

            # Render text lines
            for i, line in enumerate(info_lines):
                y_pos = y_offset + i * 18

                # Use smaller font for detailed info
                current_font_scale = small_font_scale if i > 6 else font_scale

                # Color coding for different types of info
                if "Motion Pred:" in line:
                    color = (0, 255, 255)  # Cyan for motion
                elif "Visual Features:" in line:
                    color = (255, 0, 255)  # Magenta for visual
                elif "Enhanced:" in line:
                    color = (0, 255, 0)  # Green for enhanced detections
                elif "GPS:" in line or "Speed:" in line:
                    color = (255, 255, 0)  # Yellow for GPS
                elif "Consolidations:" in line or "Reappearances:" in line:
                    color = (255, 165, 0)  # Orange for consolidation
                else:
                    color = text_color  # White for basic info

                cv2.putText(
                    result,
                    line,
                    (frame.shape[1] - panel_width + 5, y_pos),
                    font,
                    current_font_scale,
                    color,
                    1,
                )

            # === DETECTION QUALITY INDICATORS ===
            # Show quality indicators at the bottom of panel
            if detections:
                best_detection = max(detections, key=lambda d: getattr(d, "score", 0))
                best_score = getattr(best_detection, "score", 0)

                # Show best detection score with color coding
                score_color = (
                    (0, 255, 0)
                    if best_score > 0.7
                    else (0, 255, 255) if best_score > 0.5 else (0, 0, 255)
                )
                cv2.putText(
                    result,
                    f"Best: {best_score:.3f}",
                    (frame.shape[1] - panel_width + 5, panel_height - 10),
                    font,
                    font_scale,
                    score_color,
                    2,
                )

            return result

        except Exception as e:
            self.logger.error(f"Error adding enhanced info panel: {e}")
            return frame

    def _draw_tracks(
        self, frame: np.ndarray, tracks: List[Track], scale_x: float, scale_y: float
    ) -> np.ndarray:
        """Enhanced track drawing with motion and visual feature indicators"""

        if frame is None or len(frame.shape) != 3:
            return self.blank_frame.copy()

        if tracks is None:
            tracks = []

        try:
            result = frame.copy()
            for track in tracks:
                # Determine track color based on enhanced attributes
                if getattr(track, "motion_compensated", False):
                    color = (0, 255, 255)  # Cyan for motion compensated
                elif getattr(track, "prediction_match", False):
                    color = (255, 0, 255)  # Magenta for prediction match
                elif getattr(track, "reappearance_match", False):
                    color = (0, 165, 255)  # Orange for reappearance
                else:
                    # Use standard colors based on state
                    color = TRACK_COLORS.get(
                        getattr(track, "state", "confirmed"), (255, 255, 255)
                    )

                # Get bounding box
                bbox = track.to_tlbr()
                x1, y1, x2, y2 = bbox
                x1, x2 = int(x1 * scale_x), int(x2 * scale_x)
                y1, y2 = int(y1 * scale_y), int(y2 * scale_y)

                # Draw bounding box with enhanced thickness for special tracks
                thickness = (
                    4
                    if getattr(track, "motion_compensated", False)
                    else 3 if track.state == "confirmed" else 2
                )
                cv2.rectangle(result, (x1, y1), (x2, y2), color, thickness)

                # Enhanced track info
                track_info_parts = [f"ID:{track.track_id}"]

                if hasattr(track, "hits"):
                    track_info_parts.append(f"H:{track.hits}")

                # Add enhancement indicators
                if getattr(track, "motion_compensated", False):
                    track_info_parts.append("MC")
                if getattr(track, "prediction_match", False):
                    match_score = getattr(track, "match_score", 0)
                    track_info_parts.append(f"P:{match_score:.2f}")
                if getattr(track, "reappearance_match", False):
                    track_info_parts.append("R")

                if track.state == "confirmed":
                    track_info_parts.append("âœ“")

                track_info = " ".join(track_info_parts)

                # Create enhanced text background
                text_size = cv2.getTextSize(
                    track_info, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2
                )[0]
                bg_color = color
                cv2.rectangle(
                    result,
                    (x1, y1 - text_size[1] - 8),
                    (x1 + text_size[0] + 4, y1),
                    bg_color,
                    -1,
                )

                # Draw text with contrasting color
                text_color = (0, 0, 0) if sum(color) > 400 else (255, 255, 255)
                cv2.putText(
                    result,
                    track_info,
                    (x1 + 2, y1 - 4),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.5,
                    text_color,
                    2,
                )

                # Draw enhanced trajectory for confirmed tracks
                if (
                    track.state == "confirmed"
                    and len(getattr(track, "detections", [])) > 1
                    and hasattr(track, "detections")
                ):
                    self._draw_trajectory_enhanced(
                        result, track, scale_x, scale_y, color
                    )

            return result

        except Exception as e:
            self.logger.error(f"Error drawing enhanced tracks: {e}")
            return frame

    def _draw_trajectory(
        self,
        frame: np.ndarray,
        track: Track,
        scale_x: float,
        scale_y: float,
        color: Tuple[int, int, int],
    ):
        """Draw enhanced trajectory with motion prediction indicators"""
        try:
            recent_detections = track.detections[-min(10, len(track.detections)) :]

            if len(recent_detections) < 2:
                return

            points = []
            for detection in recent_detections:
                center = detection.center
                scaled_center = (int(center[0] * scale_x), int(center[1] * scale_y))
                points.append(scaled_center)

            # Draw trajectory lines with varying thickness
            for i in range(1, len(points)):
                # Thicker line for more recent trajectory
                thickness = max(1, 3 - i // 3)
                cv2.line(frame, points[i - 1], points[i], color, thickness)

            # Draw trajectory points with size indicating recency
            for i, point in enumerate(points):
                radius = 4 if i == len(points) - 1 else max(2, 3 - i // 3)
                cv2.circle(frame, point, radius, color, -1)

                # Add prediction indicator for the latest point
                if i == len(points) - 1 and getattr(track, "prediction_match", False):
                    # Draw prediction indicator
                    cv2.circle(frame, point, radius + 3, (255, 255, 255), 1)

        except Exception as e:
            self.logger.error(f"Error drawing enhanced trajectory: {e}")

    def visualize_frame(
        self,
        frame: np.ndarray,
        detections: List[Detection],
        tracks: List[Track],
        gps_data: Optional[Dict] = None,
        frame_info: Optional[Dict] = None,
    ) -> bool:
        """
        Visualize a single frame with detections and tracks

        Args:
            frame: Input frame
            detections: Raw detections for this frame
            tracks: Active tracks
            gps_data: Optional GPS data
            frame_info: Optional frame information

        Returns:
            False if user wants to quit, True otherwise
        """
        self.frame_count += 1

        # Input validation - use blank frame if input is invalid
        if frame is None or not isinstance(frame, np.ndarray) or len(frame.shape) != 3:
            self.logger.warning(
                f"Invalid frame received (type: {type(frame)}, frame_count: {self.frame_count})"
            )
            vis_frame = self.blank_frame.copy()
        else:
            # Create visualization with error handling
            try:
                vis_frame = self._create_visualization(
                    frame, detections, tracks, gps_data, frame_info
                )
                if vis_frame is None:
                    self.logger.warning("Visualization failed, using blank frame")
                    vis_frame = self.blank_frame.copy()
            except Exception as e:
                self.logger.error(f"Visualization error: {e}")
                vis_frame = self.blank_frame.copy()
                cv2.putText(
                    vis_frame,
                    f"Visualization error: {str(e)[:50]}",
                    (10, 50),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.7,
                    (0, 0, 255),
                    2,
                )

        # Calculate FPS
        current_time = time.time()
        fps = 1.0 / max(0.001, current_time - self.last_time)
        self.fps_history.append(fps)
        self.last_time = current_time

        # Keep only recent FPS values
        if len(self.fps_history) > 30:
            self.fps_history = self.fps_history[-30:]

        # Add FPS overlay
        avg_fps = np.mean(self.fps_history)
        cv2.putText(
            vis_frame,
            f"FPS: {avg_fps:.1f}",
            (10, 30),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.7,
            (0, 255, 0),
            2,
        )

        # Display frame
        cv2.imshow(self.window_name, vis_frame)

        # Handle keyboard input
        key = cv2.waitKey(1) & 0xFF

        if key == ord("q"):
            return False  # Quit
        elif key == ord("p"):
            # Pause - wait for another key press
            cv2.putText(
                vis_frame,
                "PAUSED - Press any key to continue",
                (vis_frame.shape[1] // 4, vis_frame.shape[0] // 2),
                cv2.FONT_HERSHEY_SIMPLEX,
                1,
                (0, 0, 255),
                2,
            )
            cv2.imshow(self.window_name, vis_frame)
            self.logger.info("â¸ï¸  Paused - Press any key to continue...")
            cv2.waitKey(0)
        elif key == ord("s"):
            # Save screenshot
            screenshot_name = f"argus_track_screenshot_{self.frame_count:06d}.jpg"
            cv2.imwrite(screenshot_name, vis_frame)
            self.logger.info(f"ðŸ“¸ Screenshot saved: {screenshot_name}")

        return True  # Continue

    def _create_visualization(
        self,
        frame: np.ndarray,
        detections: List[Detection],
        tracks: List[Track],
        gps_data: Optional[Dict] = None,
        frame_info: Optional[Dict] = None,
    ) -> np.ndarray:
        """Create comprehensive visualization frame"""
        # Safety check for frame
        if frame is None or not isinstance(frame, np.ndarray) or len(frame.shape) != 3:
            return self.blank_frame.copy()

        # Resize frame to display size if needed
        try:
            vis_frame = self._resize_frame(frame)
        except Exception as e:
            self.logger.error(f"Error resizing frame: {e}")
            return self.blank_frame.copy()

        # Calculate scale factors for coordinate adjustment
        scale_x = vis_frame.shape[1] / max(1, frame.shape[1])
        scale_y = vis_frame.shape[0] / max(1, frame.shape[0])

        # Draw raw detections first (lighter overlay)
        vis_frame = self._draw_detections(vis_frame, detections, scale_x, scale_y)

        # Draw tracks (more prominent)
        vis_frame = self._draw_tracks(vis_frame, tracks, scale_x, scale_y)

        # Add information panels
        if self.show_info_panel:
            vis_frame = self._add_info_panel(
                vis_frame, detections, tracks, gps_data, frame_info
            )

        return vis_frame

    def _resize_frame(self, frame: np.ndarray) -> np.ndarray:
        """Resize frame to display size - DEFENSIVE"""
        # Handle None or invalid frame
        if frame is None:
            return self.blank_frame.copy()

        if len(frame.shape) != 3:
            return self.blank_frame.copy()

        if frame.shape[:2] == (self.display_size[1], self.display_size[0]):
            return frame.copy()

        try:
            return cv2.resize(frame, self.display_size)
        except Exception as e:
            self.logger.error(f"Error resizing frame: {e}")
            return self.blank_frame.copy()

    def _draw_detections(
        self,
        frame: np.ndarray,
        detections: List[Detection],
        scale_x: float,
        scale_y: float,
    ) -> np.ndarray:
        """Draw raw detections with semi-transparent overlay"""
        if frame is None or len(frame.shape) != 3:
            return self.blank_frame.copy()

        # Safety check - if frame is valid but detections is None
        if detections is None:
            detections = []

        # Create overlay for semi-transparency
        try:
            overlay = frame.copy()
            for detection in detections:
                bbox = detection.bbox
                x1, y1, x2, y2 = bbox
                x1, x2 = int(x1 * scale_x), int(x2 * scale_x)
                y1, y2 = int(y1 * scale_y), int(y2 * scale_y)
                cv2.rectangle(overlay, (x1, y1), (x2, y2), (255, 255, 255), 1)
                conf_text = f"{detection.score:.2f}"
                cv2.putText(
                    overlay,
                    conf_text,
                    (x1, y1 - 5),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.4,
                    (255, 255, 255),
                    1,
                )

            # Blend overlay with original frame
            result = cv2.addWeighted(frame, 0.8, overlay, 0.2, 0)
            return result
        except Exception as e:
            self.logger.error(f"Error drawing detections: {e}")
            return frame  # Return original frame if drawing fails

    def close(self):
        """Close the visualization window"""
        try:
            cv2.destroyWindow(self.window_name)
            self.logger.info(f"ðŸ–¥ï¸  Closed visualization window")

            # Print final statistics
            if self.fps_history:
                avg_fps = np.mean(self.fps_history)
                self.logger.info(f"ðŸ“Š Average FPS: {avg_fps:.1f}")
                self.logger.info(f"ðŸ“Š Total frames processed: {self.frame_count}")
        except Exception as e:
            self.logger.error(f"Error closing visualization window: {e}")


def draw_tracks(
    frame: np.ndarray,
    tracks: List[Track],
    show_trajectory: bool = True,
    show_id: bool = True,
    show_state: bool = True,
) -> np.ndarray:
    """
    Draw tracks on frame (existing function - now enhanced with error handling)

    Args:
        frame: Input frame
        tracks: List of tracks to draw
        show_trajectory: Whether to show track trajectories
        show_id: Whether to show track IDs
        show_state: Whether to show track states

    Returns:
        Frame with track visualizations
    """
    # Handle None inputs
    if frame is None:
        # Create blank frame
        blank_frame = np.zeros((720, 1280, 3), dtype=np.uint8)
        cv2.putText(
            blank_frame,
            "No frame data available",
            (400, 360),
            cv2.FONT_HERSHEY_SIMPLEX,
            1,
            (255, 255, 255),
            2,
        )
        return blank_frame

    if tracks is None:
        tracks = []

    try:
        vis_frame = frame.copy()

        for track in tracks:
            # Get color based on state
            color = TRACK_COLORS.get(track.state, (255, 255, 255))

            # Draw bounding box
            x1, y1, x2, y2 = track.to_tlbr().astype(int)
            thickness = 3 if track.state == "confirmed" else 2
            cv2.rectangle(vis_frame, (x1, y1), (x2, y2), color, thickness)

            # Draw track information
            if show_id or show_state:
                label_parts = []
                if show_id:
                    label_parts.append(f"ID: {track.track_id}")
                if show_state:
                    label_parts.append(f"[{track.state}]")

                label = " ".join(label_parts)
                label_size, _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)

                # Draw label background
                cv2.rectangle(
                    vis_frame,
                    (x1, y1 - label_size[1] - 10),
                    (x1 + label_size[0], y1),
                    color,
                    -1,
                )

                # Draw text
                cv2.putText(
                    vis_frame,
                    label,
                    (x1, y1 - 5),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.5,
                    (255, 255, 255),
                    2,
                )

            # Draw trajectory for confirmed tracks
            if (
                show_trajectory
                and track.state == "confirmed"
                and len(track.detections) > 1
            ):
                points = []
                for det in track.detections[-10:]:  # Last 10 detections
                    center = det.center
                    points.append(center.astype(int))

                points = np.array(points)
                cv2.polylines(vis_frame, [points], False, color, 2)

                # Draw points
                for point in points:
                    cv2.circle(vis_frame, tuple(point), 3, color, -1)

        return vis_frame
    except Exception as e:
        # In case of error, log and return original frame
        logging.error(f"Error in draw_tracks: {e}")
        return frame


def create_track_overlay(
    frame: np.ndarray, tracks: List[Track], alpha: float = 0.3
) -> np.ndarray:
    """
    Create semi-transparent overlay with track information

    Args:
        frame: Input frame
        tracks: List of tracks
        alpha: Transparency level (0-1)

    Returns:
        Frame with overlay
    """
    # Handle None inputs
    if frame is None:
        blank_frame = np.zeros((720, 1280, 3), dtype=np.uint8)
        return blank_frame

    if tracks is None or len(tracks) == 0:
        return frame.copy()

    try:
        overlay = np.zeros_like(frame)

        for track in tracks:
            if track.state != "confirmed":
                continue

            # Create mask for track region
            mask = np.zeros(frame.shape[:2], dtype=np.uint8)
            x1, y1, x2, y2 = track.to_tlbr().astype(int)
            cv2.rectangle(mask, (x1, y1), (x2, y2), 255, -1)

            # Apply color overlay
            color = TRACK_COLORS[track.state]
            overlay[mask > 0] = color

        # Blend with original frame
        result = cv2.addWeighted(frame, 1 - alpha, overlay, alpha, 0)

        return result
    except Exception as e:
        logging.error(f"Error in create_track_overlay: {e}")
        return frame.copy()  # Return original frame if error

================
File: argus_track/trackers/__init__.py
================
"""Tracking algorithms"""

from .unique_tracker import UnifiedLightPostTracker

__all__ = ["UnifiedLightPostTracker"]

================
File: argus_track/__init__.py
================
# argus_track/__init__.py - FIXED imports

"""
Argus Track: Stereo ByteTrack Light Post Tracking System
========================================================

A specialized implementation of ByteTrack for tracking light posts in stereo video sequences
with GPS integration for precise 3D geolocation estimation.

Key Features:
- Stereo vision processing with 3D triangulation
- Optimized for static/slow-moving objects
- GPS data integration for geolocation
- YOLOv11 support for advanced object detection
- Modular architecture with clear separation of concerns
- Comprehensive logging and error handling
- Type hints and documentation throughout

Author: Argus Track Team
Date: 2025
License: MIT
"""

from argus_track.__version__ import __version__
from argus_track.config import StaticCarConfig, TrackerConfig
from argus_track.core import Detection, GPSData, Track
from argus_track.detectors import ObjectDetector
from argus_track.detectors.yolov11 import YOLOv11Detector
from argus_track.trackers import UnifiedLightPostTracker

__all__ = [
    "__version__",
    "TrackerConfig",
    "StaticCarConfig",
    "Detection",
    "Track",
    "GPSData",
    "UnifiedLightPostTracker",
    "YOLOv11Detector",
    "ObjectDetector",
]

================
File: argus_track/utils/smart_track_manager.py
================
# argus_track/utils/clean_track_manager.py

"""
Clean Track Manager - GPS-informed tracking without complexity
============================================================

Focused track management that uses GPS movement context to solve:
- Track fragmentation
- Track ID resurrection
- Duplicate ID assignment

GPS Movement Logic:
- If vehicle moved forward > 50m, don't reuse old track IDs
- If vehicle is stationary, allow limited track reappearance
- Conservative ID management for forward motion
"""

import logging
import time
from dataclasses import dataclass, field
from typing import Any, Dict, List, Set

import numpy as np

from ..config import TrackerConfig
from ..core import Detection
from ..utils.gps_motion_prediction import (
    MotionPredictor,
    create_motion_prediction_config,
)


@dataclass
class TrackMemory:
    """Simple track memory without complex features"""

    track_id: int
    last_seen_frame: int
    last_position: np.ndarray
    detection_count: int = 0
    confidence_history: List[float] = field(default_factory=list)
    creation_time: float = field(default_factory=time.time)
    last_update_time: float = field(default_factory=time.time)

    def update(self, detection: Detection, frame_id: int):
        """Update track memory with new detection"""
        self.last_position = detection.center
        self.last_seen_frame = frame_id
        self.detection_count += 1
        self.last_update_time = time.time()

        self.confidence_history.append(detection.score)
        if len(self.confidence_history) > 10:
            self.confidence_history = self.confidence_history[-10:]

class CleanTrackManager:
    """
    Clean track manager with GPS movement context

    Key principles:
    1. Use GPS to understand vehicle movement
    2. Prevent impossible track resurrections in forward motion
    3. Conservative ID management
    4. Simple, predictable behavior
    """

    # Temporal resurrection constants
    MIN_DISTANCE_DIFFERENT_OBJECT_M = (
        12.0  # Vehicle travel distance to consider new object(15)
    )
    FORBID_DISTANCE_THRESHOLD_M = 20.0  # Distance to proactively forbid resurrections
    MAX_TIME_SAME_OBJECT_S = 2.5  # Max time for same object resurrection(3)
    FAST_SPEED_THRESHOLD_MS = 5.0  # Speed threshold for restrictive policy
    STATIONARY_THRESHOLD_MS = 0.5  # Speed threshold for lenient policy
    MAX_FRAMES_FAST_MOVING = 3  # Max frames gap at high speed
    MAX_FRAMES_SAME_POSITION = 5  # Max frames for same position resurrection
    DETECTION_POSITION_TOLERANCE_PX = 50.0  # Tolerance for "same position"

    def __init__(self, config: TrackerConfig):
        """Initialize clean track manager"""
        self.config = config
        self.logger = logging.getLogger(f"{__name__}.CleanTrackManager")

        # Track memory storage
        self.track_memories: Dict[int, TrackMemory] = {}
        self.active_track_ids: Set[int] = set()
        self.lost_track_ids: Set[int] = set()

        # GPS movement context
        self.vehicle_speed: float = 0.0
        self.total_distance_moved: float = 0.0
        self.distance_since_last_cleanup: float = 0.0

        # ID management
        self.next_track_id = 1
        self.id_reuse_forbidden: Set[int] = set()  # IDs we should never reuse

        # Statistics
        self.total_tracks_created = 0
        self.total_tracks_lost = 0
        self.total_resurrections_prevented = 0
        self.fragmentation_fixes = 0

        self.track_positions = {}  # track_id -> last_known_position
        self.track_death_positions = {}  # track_id -> position_when_lost
        self.forbidden_resurrections = set()  # track_ids that should never resurrect

        self.motion_config = create_motion_prediction_config(
            object_distance_m=30.0,
            gps_accuracy_threshold_m=3.0,
            prediction_tolerance_px=15.0,
            enable_debug=True,
        )
        self.motion_predictor = MotionPredictor(self.motion_config)

        # GPS context
        self.current_gps = None
        self.previous_gps = None
        # Initialize vehicle movement tracking
        self.current_vehicle_movement = None
        self.previous_vehicle_movement = None

        self.motion_predictions = {}

        self.logger.info("Motion prediction enabled in CleanTrackManager")

        self.logger.info("Clean Track Manager initialized")

    def update_gps_context(self, current_gps, previous_gps=None):
        """Update GPS context for motion prediction"""
        # Don't overwrite previous_gps if we already have one from the actual previous frame
        if self.current_gps is not None:
            self.previous_gps = self.current_gps

        self.current_gps = current_gps

        # Only use passed previous_gps if we don't have context yet
        if self.previous_gps is None and previous_gps is not None:
            self.previous_gps = previous_gps

        self.logger.debug(
            f"GPS context updated: prev_time={getattr(self.previous_gps, 'timestamp', 'None')}, "
            f"curr_time={getattr(self.current_gps, 'timestamp', 'None')}"
        )

    def update_movement_context_try(self, gps_data):
        """Update movement context from GPS data"""
        if gps_data:
            # Calculate speed in m/s
            speed_ms = getattr(gps_data, "speed", 0.0) if gps_data else 0.0

            # Create a simple movement object
            from collections import namedtuple

            VehicleMovement = namedtuple("VehicleMovement", ["speed_ms"])
            self.current_vehicle_movement = VehicleMovement(speed_ms=speed_ms)
        else:
            self.current_vehicle_movement = None

    def update_movement_context(
        self, vehicle_speed: float, distance_moved: float, total_distance: float
    ):
        """Update GPS movement context for tracking decisions"""
        self.vehicle_speed = vehicle_speed
        self.total_distance_moved = total_distance
        self.distance_since_last_cleanup += distance_moved

        # If we've moved forward significantly, mark old IDs as forbidden
        if distance_moved > 10.0:  # 10 meters forward
            self._mark_distant_tracks_as_forbidden()

        # Periodic cleanup based on distance
        if self.distance_since_last_cleanup > 50.0:  # Every 50 meters
            self._cleanup_distant_tracks()
            self.distance_since_last_cleanup = 0.0

    def _calculate_association_tolerance(self) -> float:
        """Calculate dynamic tolerance based on vehicle motion"""
        base_tolerance = 300.0

        if self.vehicle_speed > 1.0:  # Vehicle moving
            # Increase tolerance based on speed (max 2x for 10+ m/s)
            speed_factor = min(2.0, 1.0 + (self.vehicle_speed / 10.0))
            return base_tolerance * speed_factor

        return base_tolerance

    def _generate_motion_predictions(self, frame_id: int) -> Dict[int, np.ndarray]:
        """Generate pixel-space predictions and maintain track continuity"""
        self.motion_predictions.clear()

        if self.previous_gps is None or self.current_gps is None:
            self.logger.debug(f"Frame {frame_id}: No GPS data for motion prediction")
            return {}

        # ENHANCED: Include lost tracks that might reappear
        current_positions = {}

        # Add active tracks
        for track_id in self.active_track_ids:
            if track_id in self.track_positions:
                current_positions[track_id] = self.track_positions[track_id]

        # NEW: Add recently lost tracks (within 60 frames = ~6 seconds)
        recently_lost_tracks = {}
        for track_id in list(self.lost_track_ids):
            if track_id in self.track_memories:
                memory = self.track_memories[track_id]
                frames_since_lost = frame_id - memory.last_seen_frame

                # Keep recently lost tracks alive with predictions
                if frames_since_lost <= 60 and track_id in self.track_positions:
                    recently_lost_tracks[track_id] = self.track_positions[track_id]
                    self.logger.debug(
                        f"Frame {frame_id}: Including lost track {track_id} "
                        f"in predictions (lost {frames_since_lost} frames ago)"
                    )

        # Combine active and recently lost
        all_positions = {**current_positions, **recently_lost_tracks}

        if not all_positions:
            self.logger.debug(f"Frame {frame_id}: No track positions for prediction")
            return {}

        try:
            # Use existing MotionPredictor
            predictions = self.motion_predictor.predict_object_positions(
                self.previous_gps, self.current_gps, all_positions
            )

            # Store for debugging and extract positions
            self.motion_predictions = predictions
            predicted_positions = {}

            for track_id, info in predictions.items():
                predicted_positions[track_id] = info["predicted_position"]
                confidence = info["confidence"]

                # NEW: Reactivate lost tracks with good predictions
                if track_id in recently_lost_tracks and confidence > 0.6:
                    self.logger.info(
                        f"Frame {frame_id}: Reactivating lost track {track_id} "
                        f"with prediction confidence {confidence:.2f}"
                    )
                    self.lost_track_ids.discard(track_id)
                    self.active_track_ids.add(track_id)

                    # Update position with prediction
                    self.track_positions[track_id] = predicted_positions[track_id]

                self.logger.debug(
                    f"Frame {frame_id}: Track {track_id} predicted at "
                    f"{predicted_positions[track_id]} (conf: {confidence:.2f})"
                )

            return predicted_positions

        except Exception as e:
            self.logger.error(f"Motion prediction failed: {e}")
            return {}

    def process_frame_detections(
        self, detections: List[Detection], frame_id: int, timestamp: float
    ) -> List[Detection]:
        """
        Process frame detections with GPS-informed track management

        Args:
            detections: Raw detections from overlap fixer
            frame_id: Current frame ID
            timestamp: Frame timestamp

        Returns:
            Detections with clean track IDs
        """
        processed_detections = []

        for detection in detections:
            original_track_id = detection.track_id

            # Check if this track ID should be reused
            clean_track_id = self._get_clean_track_id(
                original_track_id, detection, frame_id
            )

            # Update detection with clean ID
            detection.track_id = clean_track_id
            processed_detections.append(detection)

            # Update track memory
            self._update_track_memory(detection, frame_id)

        if frame_id % 20 == 0:
            self._cleanup_old_tracks()

        self._handle_lost_tracks(frame_id)

        return processed_detections

    def _handle_resurrection_and_new_tracks(
        self, original_id: int, detection: Detection, frame_id: int
    ) -> int:
        """Handle resurrection logic and new track creation with more lenient rules"""

        # Check if this is a forbidden resurrection
        if original_id in getattr(self, "forbidden_resurrections", set()):
            new_id = self._assign_new_track_id()
            self.total_resurrections_prevented += 1
            self.logger.info(
                f"Frame {frame_id}: Prevented forbidden resurrection {original_id} -> {new_id}"
            )
            return new_id

        # Enhanced resurrection check - be more lenient for recent tracks
        if original_id in self.lost_track_ids:
            if self._resurrection_makes_spatial_sense_enhanced(
                original_id, detection, frame_id
            ):
                # Allow resurrection
                self.lost_track_ids.discard(original_id)
                self.active_track_ids.add(original_id)
                self.logger.info(
                    f"Frame {frame_id}: Allowed logical resurrection {original_id}"
                )
                return original_id
            else:
                # Block resurrection but be less aggressive
                self.forbidden_resurrections.add(original_id)
                new_id = self._assign_new_track_id()
                self.total_resurrections_prevented += 1
                self.logger.info(
                    f"Frame {frame_id}: Prevented illogical resurrection {original_id} -> {new_id}"
                )
                return new_id

        # Create new track
        new_id = self._assign_new_track_id()
        return new_id

    def _resurrection_makes_temporal_sense(
        self, track_id: int, detection: Detection, frame_id: int
    ) -> bool:

        if track_id not in self.track_memories:
            return False

        memory = self.track_memories[track_id]
        frames_since_death = frame_id - memory.last_seen_frame
        time_since_death = frames_since_death / 10.0  # seconds (assuming 10fps)

        # Calculate how far vehicle has traveled since track death
        distance_traveled = self.vehicle_speed * time_since_death

        # CORE LOGIC: If vehicle has moved far enough, this CANNOT be the same object

        # For light posts and street infrastructure:
        # - Typical spacing: 30-100 meters apart
        # - If vehicle traveled >15m, likely a different object

        min_distance_for_new_object = 15.0  # meters

        if distance_traveled > min_distance_for_new_object:
            self.logger.warning(
                f"Resurrection blocked: track {track_id} - vehicle traveled {distance_traveled:.1f}m "
                f"since death (>{min_distance_for_new_object}m = different object)"
            )
            return False

        # Additional check: Time-based cutoff
        # Even at slow speeds, after enough time it's likely a different object
        max_time_same_object = 3.0  # seconds

        if time_since_death > max_time_same_object:
            self.logger.warning(
                f"Resurrection blocked: track {track_id} - {time_since_death:.1f}s since death "
                f"(>{max_time_same_object}s = different object)"
            )
            return False

        # If we get here, resurrection might be legitimate
        return True

    def _resurrection_makes_spatial_sense_enhanced(
        self, track_id: int, detection: Detection, frame_id: int
    ) -> bool:
        """
        ENHANCED: Spatial check that considers screen position reuse
        """

        if track_id not in self.track_death_positions:
            return False

        death_position = self.track_death_positions[track_id]
        new_position = detection.center
        distance = np.linalg.norm(new_position - death_position)

        # For same screen position resurrections, be more restrictive
        if distance < 50.0:  # Very close to death position

            # This could be legitimate (same object reappearing) OR
            # different object at same screen position

            # Use temporal logic to decide
            if not self._resurrection_makes_temporal_sense(
                track_id, detection, frame_id
            ):
                return False

            # Additional check: if vehicle is moving, same position resurrections are suspicious
            if self.vehicle_speed > 1.0:

                memory = self.track_memories[track_id]
                frames_since_death = frame_id - memory.last_seen_frame

                # For moving vehicle, only allow very quick resurrections at same position
                if frames_since_death > 5:  # 0.5 seconds
                    self.logger.warning(
                        f"Resurrection blocked: track {track_id} - same position after {frames_since_death} "
                        f"frames with moving vehicle (likely different object)"
                    )
                    return False

        # For distant resurrections, use standard distance check
        max_distance = 100.0  # Reasonable limit
        if distance > max_distance:
            self.logger.debug(
                f"Resurrection blocked: track {track_id} moved {distance:.1f}px (max: {max_distance})"
            )
            return False

        return True

    def _proactive_forbid_distant_tracks(self, frame_id: int):
        """
        PROACTIVE: Forbid resurrections for tracks that are definitely behind us
        """

        tracks_to_forbid = []

        for track_id in list(self.lost_track_ids):
            if track_id in self.track_memories:
                memory = self.track_memories[track_id]
                frames_since_death = frame_id - memory.last_seen_frame
                time_since_death = frames_since_death / 10.0

                # Calculate distance traveled since death
                distance_traveled = self.vehicle_speed * time_since_death

                # If we've traveled far enough, this track is definitely behind us
                forbid_distance = 20.0  # meters

                if distance_traveled > forbid_distance:
                    tracks_to_forbid.append(track_id)

        # Move to forbidden resurrections
        for track_id in tracks_to_forbid:
            self.lost_track_ids.discard(track_id)
            self.forbidden_resurrections.add(track_id)
            self.logger.debug(
                f"Track {track_id} proactively forbidden - vehicle traveled "
                f"{self.vehicle_speed * (frame_id - self.track_memories[track_id].last_seen_frame) / 10.0:.1f}m"
            )

    def _resurrection_vehicle_context_check(
        self, track_id: int, detection: Detection, frame_id: int
    ) -> bool:
        """
        Check resurrection against vehicle movement context
        """

        # If vehicle is stationary, allow more resurrections
        if self.vehicle_speed < 0.5:
            return True

        # If vehicle is moving fast, be very restrictive
        if self.vehicle_speed > 5.0:
            memory = self.track_memories[track_id]
            frames_since_death = frame_id - memory.last_seen_frame

            # At high speed, only allow immediate resurrections (tracking gaps)
            if frames_since_death > 3:  # 0.3 seconds
                self.logger.debug(
                    f"Resurrection blocked: track {track_id} - vehicle too fast ({self.vehicle_speed:.1f}m/s) "
                    f"for {frames_since_death}-frame gap"
                )
                return False

        return True

    def _enhanced_resurrection_check(
        self, track_id: int, detection: Detection, frame_id: int
    ) -> bool:
        """
        COMPREHENSIVE: Combine all resurrection checks
        """

        # Check 1: Basic spatial sense (enhanced)
        if not self._resurrection_makes_spatial_sense_enhanced(
            track_id, detection, frame_id
        ):
            return False

        # Check 2: Temporal sense (NEW - this is the key for your problem)
        if not self._resurrection_makes_temporal_sense(track_id, detection, frame_id):
            return False

        # Check 3: Vehicle context
        if not self._resurrection_vehicle_context_check(track_id, detection, frame_id):
            return False

        return True

    def _get_clean_track_id(
        self, original_id: int, detection: Detection, frame_id: int
    ) -> int:
        """Enhanced track ID assignment with motion prediction"""
        detection_center = detection.center

        motion_predictions = self._generate_motion_predictions(frame_id)

        if motion_predictions:
            best_match_id = None
            best_distance = float("inf")

            for track_id, predicted_pos in motion_predictions.items():
                distance = np.linalg.norm(detection_center - predicted_pos)

                tolerance = self.motion_config.prediction_tolerance_px
                if (
                    self.current_gps
                    and hasattr(self.current_gps, "speed")
                    and self.current_gps.speed > 2.0
                ):
                    tolerance *= 2.0  # Double tolerance for fast movement

                if distance < tolerance and distance < best_distance:
                    best_match_id = track_id
                    best_distance = distance

            if best_match_id is not None:
                # IMPORTANT: Reactivate the track if it was lost
                if best_match_id in self.lost_track_ids:
                    self.lost_track_ids.discard(best_match_id)
                    self.active_track_ids.add(best_match_id)
                    self.logger.info(
                        f"Frame {frame_id}: Motion prediction reactivated track {best_match_id}"
                    )

                self.logger.info(
                    f"Frame {frame_id}: Motion prediction match {original_id} -> {best_match_id} "
                    f"(error: {best_distance:.1f}px)"
                )
                return best_match_id

        # Continue with existing fallback logic...
        return self._get_fallback_track_id(original_id, detection, frame_id)

    def _should_allow_track_reappearance(
        self, track_id: int, detection: Detection, frame_id: int
    ) -> bool:
        """
        Determine if track reappearance makes sense given GPS movement

        Logic:
        - If vehicle is stationary or slow: allow reappearance
        - If vehicle moved forward significantly: block reappearance
        - Conservative approach for forward motion
        """
        if track_id not in self.track_memories:
            return False

        track_memory = self.track_memories[track_id]
        frames_since_lost = frame_id - track_memory.last_seen_frame

        # Don't allow very old tracks to reappear
        if frames_since_lost > 30:  # ~3 seconds at 10fps
            return False

        # GPS-based logic
        if self.vehicle_speed < 1.0:  # Vehicle stationary/very slow
            # Allow reappearance for stationary vehicle
            # Object might have been temporarily occluded
            return frames_since_lost <= 15  # 1.5 seconds

        elif self.vehicle_speed < 5.0:  # Vehicle moving slowly
            # More restrictive for slow movement
            return frames_since_lost <= 10  # 1 second

        else:  # Vehicle moving fast (>5 m/s = 18 km/h)
            # Very restrictive for fast movement
            # Object should be behind the vehicle quickly
            return frames_since_lost <= 5  # 0.5 seconds

    def _assign_new_track_id(self) -> int:
        """Assign a new track ID that hasn't been used"""
        while (
            self.next_track_id in self.track_memories
            or self.next_track_id in self.id_reuse_forbidden
        ):
            self.next_track_id += 1

        new_id = self.next_track_id
        self.next_track_id += 1
        self.total_tracks_created += 1

        return new_id

    def _resurrection_makes_spatial_sense_final(
        self, track_id: int, detection: Detection, frame_id: int
    ) -> bool:
        """
        FINAL VERSION: Replace your existing _resurrection_makes_spatial_sense method with this
        """
        return self._enhanced_resurrection_check(track_id, detection, frame_id)

    def process_frame_detections_enhanced(
        self, detections: List[Detection], frame_id: int, timestamp: float
    ) -> List[Detection]:
        """
        ENHANCED: Add proactive track forbidding to your existing method
        """

        # ADDITION: Proactively forbid distant tracks
        if frame_id % 10 == 0:  # Every 10 frames
            self._proactive_forbid_distant_tracks(frame_id)

        # Continue with your existing logic...
        processed_detections = []

        for detection in detections:
            original_track_id = detection.track_id
            clean_track_id = self._get_clean_track_id(
                original_track_id, detection, frame_id
            )
            detection.track_id = clean_track_id
            processed_detections.append(detection)
            self._update_track_memory(detection, frame_id)

        if frame_id % 20 == 0:
            self._cleanup_old_tracks()

        self._handle_lost_tracks(frame_id)

        return processed_detections

    def _update_track_memory(self, detection: Detection, frame_id: int):
        """Enhanced track memory update with position tracking"""

        track_id = detection.track_id

        # Call original memory update logic
        if track_id not in self.track_memories:
            self.track_memories[track_id] = TrackMemory(
                track_id=track_id,
                last_seen_frame=frame_id,
                last_position=detection.center,
            )
            self.active_track_ids.add(track_id)

        # Update existing memory
        self.track_memories[track_id].update(detection, frame_id)

        # ENHANCEMENT: Always track current position
        self.track_positions[track_id] = detection.center.copy()

    def _should_keep_track_alive(self, track_id: int, frame_id: int) -> bool:
        """Determine if a track should be kept alive based on motion prediction"""

        if track_id not in self.track_memories:
            return False

        memory = self.track_memories[track_id]
        frames_since_seen = frame_id - memory.last_seen_frame

        # Keep tracks alive longer when vehicle is moving (they might reappear)
        if self.vehicle_speed > 1.0:
            max_frames_alive = 60  # 6 seconds at 10fps
        else:
            max_frames_alive = 30  # 3 seconds when stationary

        return frames_since_seen <= max_frames_alive

    def _handle_lost_tracks(self, current_frame: int):
        """Enhanced lost track handling with motion prediction"""

        # Find tracks that were updated this frame
        current_active = set()
        for track_id, memory in self.track_memories.items():
            if memory.last_seen_frame == current_frame:
                current_active.add(track_id)

        # Find tracks that should be marked as lost
        potentially_lost = self.active_track_ids - current_active

        for track_id in potentially_lost:
            # Check if we should keep this track alive
            if self._should_keep_track_alive(track_id, current_frame):
                self.logger.debug(
                    f"Frame {current_frame}: Keeping track {track_id} alive for motion prediction"
                )
                continue  # Don't mark as lost yet

            # Mark as truly lost
            self.active_track_ids.discard(track_id)
            self.lost_track_ids.add(track_id)

            # Remember where this track "died"
            if track_id in self.track_positions:
                self.track_death_positions[track_id] = self.track_positions[
                    track_id
                ].copy()

            self.total_tracks_lost += 1
            self.logger.debug(f"Track {track_id} lost at frame {current_frame}")

    def _cleanup_old_tracks(self):
        """Cleanup old track data to prevent memory bloat"""

        # Move very old lost tracks to forbidden resurrections
        very_old_tracks = []
        for track_id in self.lost_track_ids:
            if track_id in self.track_memories:
                memory = self.track_memories[track_id]
                if hasattr(memory, "last_seen_frame"):
                    # If track was lost more than 30 frames ago, forbid resurrection
                    current_frame = max(
                        [m.last_seen_frame for m in self.track_memories.values()]
                    )
                    if current_frame - memory.last_seen_frame > 30:
                        very_old_tracks.append(track_id)

        for track_id in very_old_tracks:
            self.lost_track_ids.discard(track_id)
            self.forbidden_resurrections.add(track_id)
            self.logger.debug(
                f"Track {track_id} moved to forbidden resurrections (too old)"
            )

    def _mark_distant_tracks_as_forbidden(self):
        """Mark tracks as forbidden for reuse when vehicle moves forward significantly"""
        # Mark lost tracks as forbidden if vehicle moved forward
        if self.vehicle_speed > 2.0:  # Moving forward at reasonable speed
            newly_forbidden = set()

            for track_id in self.lost_track_ids.copy():
                if track_id in self.track_memories:
                    # This track is now behind the vehicle, forbid reuse
                    self.id_reuse_forbidden.add(track_id)
                    newly_forbidden.add(track_id)

            # Remove from lost tracks (they're now forbidden)
            self.lost_track_ids -= newly_forbidden

            if newly_forbidden:
                self.logger.debug(
                    f"Marked {len(newly_forbidden)} track IDs as forbidden due to forward movement"
                )

    def _cleanup_distant_tracks(self):
        """Cleanup tracks that are definitely behind the vehicle"""
        # Remove very old tracks from memory
        current_time = time.time()
        to_remove = []

        for track_id, memory in self.track_memories.items():
            age = current_time - memory.last_update_time

            # Remove tracks older than 30 seconds
            if age > 30.0:
                to_remove.append(track_id)

        for track_id in to_remove:
            del self.track_memories[track_id]
            self.active_track_ids.discard(track_id)
            self.lost_track_ids.discard(track_id)
            self.id_reuse_forbidden.add(track_id)  # Never reuse

        if to_remove:
            self.logger.debug(f"Cleaned up {len(to_remove)} old tracks")

        # Limit forbidden set size (keep memory reasonable)
        if len(self.id_reuse_forbidden) > 500:
            # Remove oldest forbidden IDs
            forbidden_list = sorted(list(self.id_reuse_forbidden))
            self.id_reuse_forbidden = set(forbidden_list[-400:])  # Keep newest 400

    def _get_fallback_track_id(self, original_id: int, detection, frame_id: int) -> int:
        """
        FIXED: Fallback track ID assignment that USES temporal logic
        """
        detection_center = detection.center

        # Step 1: Try to match with existing active tracks (anti-fragmentation)
        for active_id in self.active_track_ids:
            if active_id in self.track_positions:
                distance = np.linalg.norm(
                    detection_center - self.track_positions[active_id]
                )

                # Use dynamic tolerance based on vehicle speed
                base_tolerance = 300.0  # Your working value
                speed_factor = self.vehicle_speed * 2.0
                dynamic_tolerance = base_tolerance + min(speed_factor, 25.0)

                if distance < dynamic_tolerance:
                    self.logger.info(
                        f"Frame {frame_id}: Prevented fragmentation {original_id} -> {active_id}"
                    )
                    return active_id

        # Step 2: FIXED - Use your enhanced resurrection logic instead of bypassing it
        return self._handle_resurrection_and_new_tracks(
            original_id, detection, frame_id
        )

    def get_statistics(self) -> Dict[str, Any]:
        """Enhanced statistics with fragmentation and resurrection info"""

        # Your existing statistics
        base_stats = {
            "active_tracks": len(self.active_track_ids),
            "lost_tracks": len(self.lost_track_ids),
            "tracks_in_memory": len(self.track_memories),
            "forbidden_ids": len(self.id_reuse_forbidden),
            "total_tracks_created": self.total_tracks_created,
            "total_tracks_lost": self.total_tracks_lost,
            "resurrections_prevented": self.total_resurrections_prevented,
            "next_track_id": self.next_track_id,
            "vehicle_speed": self.vehicle_speed,
            "distance_moved": self.total_distance_moved,
        }

        # ADD THESE NEW METRICS:
        enhanced_stats = {
            **base_stats,
            "forbidden_resurrections": len(self.forbidden_resurrections),
            "death_positions_tracked": len(self.track_death_positions),
            "current_positions_tracked": len(self.track_positions),
            "avg_tracks_per_frame": len(self.active_track_ids),
            "resurrection_prevention_rate": len(self.forbidden_resurrections)
            / max(1, self.total_tracks_created),
        }

        return enhanced_stats

================
File: argus_track/config.py
================
# argus_track/config.py (SIMPLIFIED VERSION)

"""Simplified Configuration for Unified Tracker"""

from dataclasses import dataclass


@dataclass
class TrackerConfig:
    """Simplified configuration for unified light post tracker"""

    # === DETECTION PARAMETERS ===
    detection_conf: float = 0.20  # Detection confidence threshold
    detection_iou: float = 0.5  # NMS IoU threshold
    tracker_type: str = "bytetrack.yaml"  # Ultralytics tracker config
    max_detections: int = 10  # Max detections per frame

    # === GPS SYNCHRONIZATION ===
    gps_frame_interval: int = 6  # Process every 6th frame for GPS sync

    # === TRACK MANAGEMENT ===
    max_track_memory_age: int = 30  # Max frames to remember lost tracks

    # === STATIC CAR DETECTION ===
    enable_static_car_detection: bool = True  # Enable static car frame skipping
    static_movement_threshold_m: float = 0.3  # Minimum movement to consider moving
    static_time_threshold_s: float = 5.0  # Time before starting to skip frames

    # === OUTPUT SETTINGS ===
    export_json: bool = True  # Export JSON frame data
    export_csv: bool = True  # Export CSV GPS data
    min_detections_for_export: int = 3  # Minimum detections to include in output

    @classmethod
    def create_for_unified_tracker(cls) -> "TrackerConfig":
        """Create optimized configuration for unified tracker"""
        return cls(
            # Conservative detection settings
            detection_conf=0.20,
            detection_iou=0.5,
            tracker_type="bytetrack.yaml",
            max_detections=20,
            # GPS settings
            gps_frame_interval=6,
            # Conservative track management
            max_track_memory_age=20,  # Short memory to prevent resurrection
            # Static car detection
            enable_static_car_detection=True,
            static_movement_threshold_m=0.05,  # Very sensitive
            static_time_threshold_s=5.0,  # Start skipping quickly
            # Output settings
            export_json=True,
            export_csv=True,
            min_detections_for_export=3,  # Only export stable tracks
        )

    def get_ultralytics_track_params(self) -> dict:
        """Get parameters for model.track() call"""
        return {
            "persist": True,
            "tracker": self.tracker_type,
            "conf": self.detection_conf,
            "iou": self.detection_iou,
            "max_det": self.max_detections,
            "verbose": False,
        }


@dataclass
class StaticCarConfig:
    """Configuration for static car detection"""

    movement_threshold_meters: float = 0.9
    stationary_time_threshold: float = 5.0
    gps_frame_interval: int = 6

================
File: argus_track/main.py
================
import argparse
import logging
import time
from pathlib import Path


from argus_track import __version__
from argus_track.config import TrackerConfig
from argus_track.trackers.unique_tracker import UnifiedLightPostTracker
from argus_track.utils import setup_logging


def main():
    """Main function for unified tracking"""
    parser = argparse.ArgumentParser(
        description=f"Argus Track: Unified Light Post Tracking System v{__version__}",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Basic tracking with GPS movement context
    python main.py input.mp4 --model model.pt --show-realtime
    
    # Batch processing without visualization  
    python main.py input.mp4 --model model.pt --no-realtime
        """,
    )

    # Basic arguments
    parser.add_argument("input_video", type=str, help="Path to input video file")
    parser.add_argument(
        "--model", type=str, required=True, help="Path to YOLO model file"
    )

    # Output arguments
    parser.add_argument(
        "--output-video", type=str, help="Path for output visualization video"
    )
    parser.add_argument("--json-output", type=str, help="Path for JSON output file")
    parser.add_argument("--csv-output", type=str, help="Path for CSV output file")

    # Processing arguments
    parser.add_argument(
        "--show-realtime",
        action="store_true",
        default=True,
        help="Show real-time visualization (default: True)",
    )
    parser.add_argument(
        "--no-realtime", action="store_true", help="Disable real-time visualization"
    )

    # Tracking parameters
    parser.add_argument(
        "--detection-conf",
        type=float,
        default=0.20,
        help="Detection confidence threshold (default: 0.20)",
    )
    parser.add_argument(
        "--gps-interval",
        type=int,
        default=6,
        help="GPS frame interval (default: 6 - every 6th frame)",
    )

    # Static car detection
    parser.add_argument(
        "--disable-static-car", action="store_true", help="Disable static car detection"
    )

    # Logging
    parser.add_argument("--verbose", action="store_true", help="Enable verbose logging")
    parser.add_argument("--log-file", type=str, help="Path to log file")
    parser.add_argument("--no-save", action="store_true", help="Do not save results")

    args = parser.parse_args()

    # Validate input
    if not Path(args.input_video).exists():
        print(f"âŒ Error: Input video not found: {args.input_video}")
        return 1

    if not Path(args.model).exists():
        print(f"âŒ Error: Model file not found: {args.model}")
        return 1

    # Handle real-time display settings
    show_realtime = args.show_realtime and not args.no_realtime

    # Setup logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    setup_logging(log_file=args.log_file, level=log_level)
    logger = logging.getLogger(__name__)

    logger.info(f"ðŸš€ Argus Track v{__version__} - Unified Tracking")
    logger.info(f"ðŸ“¹ Input video: {args.input_video}")
    logger.info(f"ðŸ¤– Model: {args.model}")
    logger.info(f"ðŸ“º Real-time display: {show_realtime}")

    try:
        # Create simplified configuration
        config = TrackerConfig.create_for_unified_tracker()

        # Apply command line overrides
        config.detection_conf = args.detection_conf
        config.gps_frame_interval = args.gps_interval

        if args.disable_static_car:
            config.enable_static_car_detection = False
            logger.info("ðŸ”§ Static car detection disabled")

        logger.info("ðŸ“· Configuration created")
        logger.info(f"   Detection confidence: {config.detection_conf}")
        logger.info(f"   GPS frame interval: {config.gps_frame_interval}")
        logger.info(f"   Track memory age: {config.max_track_memory_age}")

        # Extract GPS data from video (simplified)
        logger.info("ðŸ—ºï¸ Extracting GPS data from video metadata...")
        gps_data = None

        try:
            # Try to import GPS extraction
            from argus_track.utils.gps_extraction import extract_gps_from_stereo_videos

            gps_data, extraction_method = extract_gps_from_stereo_videos(
                args.input_video, args.input_video, method="auto"
            )

            if gps_data:
                logger.info(
                    f"âœ… Extracted {len(gps_data)} GPS points using {extraction_method}"
                )
            else:
                logger.warning("âš ï¸ No GPS data found in video metadata")

        except ImportError:
            logger.warning(
                "âš ï¸ GPS extraction not available - processing without GPS context"
            )
            gps_data = None
        except Exception as e:
            logger.error(f"âŒ GPS extraction failed: {e}")
            gps_data = None

        # Initialize unified tracker
        tracker = UnifiedLightPostTracker(
            config=config,
            model_path=args.model,
            show_realtime=show_realtime,
            display_size=(1280, 720),
        )

        # Show helpful tips
        if show_realtime:
            logger.info("ðŸ–¥ï¸  Real-time visualization controls:")
            logger.info("   - Press 'q' to quit")
            logger.info("   - Press 'p' to pause/resume")
            logger.info("   - Press 's' to save screenshot")

        # Process video
        start_time = time.time()

        results = tracker.process_video(
            video_path=args.input_video,
            gps_data=gps_data,
            output_path=args.output_video,
            save_results=not args.no_save,
        )

        processing_time = time.time() - start_time

        # Print results
        logger.info("ðŸŽ‰ PROCESSING COMPLETE!")
        logger.info(f"â±ï¸  Total processing time: {processing_time:.1f} seconds")
        logger.info(f"ðŸ“Š Processing efficiency: {results['avg_fps']:.1f} FPS")

        # Track statistics
        track_stats = results["track_manager_stats"]
        logger.info("ðŸ”§ TRACKING STATISTICS:")
        logger.info(f"   Active tracks: {track_stats['active_tracks']}")
        logger.info(f"   Total tracks created: {track_stats['total_tracks_created']}")
        logger.info(
            f"   Resurrections prevented: {track_stats['resurrections_prevented']}"
        )
        logger.info(f"   Vehicle distance: {track_stats['distance_moved']:.1f}m")

        # Output files
        if not args.no_save and "json_output" in results:
            logger.info(f"ðŸ“„ JSON output: {results['json_output']}")
            logger.info(f"ðŸ“ CSV output: {results['csv_output']}")

        return 0

    except KeyboardInterrupt:
        logger.info("âŒ Processing interrupted by user (Ctrl+C)")
        return 1
    except Exception as e:
        logger.error(f"âŒ Error during processing: {e}")
        import traceback

        logger.error(traceback.format_exc())
        return 1


if __name__ == "__main__":
    exit(main())




================================================================
End of Codebase
================================================================
